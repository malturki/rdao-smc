***(
*** Part of rdao-smc: A probabilistic rewriting model of RANDAO schemes
*** 
*** Musab A. Alturki
*** November 2018
*** Runtime Verification Inc. 
)

--- import the global parameters defined in rdao-params.maude
load rdao-params.maude

***( 
*** Hash Module
***
*** This modules defines a very high-level abstraction of hashes and 
*** and hash operations. We note that this level of abstraction is 
*** enough for our purposes as we do not deal with the internals of
*** hashing, and simply assume that cryptographically secure hash 
*** functions are used.
***
)
mod HASH is
	protecting PARAMS .
	protecting NAT .

	---- Seeds are represented by naturals
	sort Seed .
	subsort Nat < Seed .

	vars S S' : Seed .

	---- Combining (XOR'ing) seeds to get a new one 
	op combineSeeds : Seed Seed -> [Seed] .
	---- #MAX-SEED-VALUE is taken to be the maximum value that can be 
	---- generated by the random function of Maude (This upper bound is 
	---- not really necessary but is there for efficiency)
	eq combineSeeds(S, S') = (S xor S') rem #MAX-SEED-VALUE .


	---- Hash datatype
	sort Hash .

	---- A hash is a seed wrapped by the hash operator (a constructor)
	---- e.g. if S is a seed, its hash is given by h(S)
	op h : Seed -> Hash [ctor frozen] .

	---- Relevant operations and properties of hashing

	---- The Commit operation
	op commit : Seed -> Hash .
	---- Committing on a seed returns the hash of that seed 
	eq commit(S) = h(S) .

	---- The Reveal operation
	op reveal : Hash -> Seed .
	---- Revealing on a hash of a seed exposes that seed 
	eq reveal(h(S)) = S .

endm


***( 
*** Nat Sets
***
*** This modules defines a set of natural numbers using an associative,
*** commutative and idempotent comma operator with identity mtIS. 
***  
*** e.g. 4 , 0 , 2 , 4 , 10 = 0 , 2 , 4 , 10 is a valid set of naturals
***
)
mod NATSET is
	protecting NAT .

	---- The set of naturals data type 
	sort NatSet .
	---- A natural number is a (singleton) set of naturals
	subsort Nat < NatSet .

	---- Set constructors
	op mtIS : -> NatSet [ctor] .
	op _,_ : NatSet NatSet -> NatSet [ctor assoc comm id: mtIS] .

	---- idempotency 
	eq I:Nat , I:Nat = I:Nat .
endm

***( 
*** Nat Lists
***
*** This modules defines a list of natural numbers using an associative
*** dot operator. Lists of naturals are heavily used by the model to 
*** represent lists of validator object identifiers (identifiers of
*** validator objects will be defined as wrapped natural numbers).
***  
*** e.g. 4 . 0 . 2 . 4 . 10 is a valid list of naturals
***
)

mod NATLIST is
	extending HASH .
	protecting NATSET .
	protecting SAMPLER .

	---- The list of naturals datatype
	sort NatList .
	---- A natural number is a (singleton) list of naturals
	subsort Nat < NatList .

	---- List constructors
	op nilIL : -> NatList [ctor] .
	op _._ : NatList NatList -> NatList [ctor assoc id: nilIL] .

	---- Operations on lists:
	vars I M N K : Nat .
	vars S : Seed . 
	vars IL IL' IL1 IL1' IL2 IL2' : NatList .

	---- Sampling a list of indices given a seed 
    op sampleIndexList : Nat Nat Seed -> [NatList] .
	---- sampleIndexList(N, M, S): 
	---- 	N: the population size (the total number of validators) 
	----    M: the sample size (the number of proposers to sample)  
	----    S: the (starting) seed to be used in computing the list of numbers 
	----    Result: Returns a list of indices (natural numbers) computed using  
	----            the sequence of seeds S, S+1, ... , S+(M-1)
	----    Note: In an actual implementation of the system, the seed S is used 
	----          along with a pseudo-random number generator to sample the 
	----          list of indices. This is not done here, as it would result 
	----          in a specification that is very inefficiently executable. 
	----          The inefficiency is due to Maude's implementation of the 
	----          random function being based on the Mersenne Twister RNG (in
	----          which computing the random value corresponding to S requires
	----          computing the previous value for S-1). In other words, Maude's 
	----          random function was not designed to support user-supplied
	----          seeds. To resolve this issue, we generate our pseudo-random
	----          number using an arithmetic combination of the seed S and the
	----          position in the list for which the number is being generated. 
	----          We note that this approach is still faithful to the original 
	----          protocol since the seed S itself is generated pseudo-randomly
	----          (using the function random), and thus, the resulting number 
	----          is also pseudo-random. 
	----    e.g.: sampleIndexList(100, 5, 748692346) = 80 . 20 . 52 . 76 . 92
	----
    ---- Sampling 0 proposers yields the empty list 
    eq sampleIndexList(N, 0, S) = nilIL .
    ---- Sampling 1 or more: compute the first sample and prepend it it to the rest   
	eq sampleIndexList(N, s(K), S) = (S * s(K) * s(s(K))) rem N . sampleIndexList(N, K, S) .
    ---- This is very inefficient -- to be avoided!
    ----eq sampleIndexList(N, s(K), S) = random(S + s(K)) rem N . sampleIndexList(N, K, S) .

    ---- First scoring function: computing compromised indices 
 	op countCompromised : NatList NatList -> [Nat] .
   ---- countCompromised(IL1, IL2): 
    ----    IL1: A list of indices (the proposers list)
    ----    IL2: A list of indices (the compromised validator list)
    ----    Result: Returns the number of indices in the first list that appear 
    ----            in the second (and hence the number of compromised validators
    ----            in the proposers list)
    ----    e.g.: countCompromised(2 . 5 . 3 . 2 . 9 . 4, 1 . 2 . 4 . 5 . 9) = 5
    ----    e.g.: countCompromised(2 . 5 . 3 . 2 . 9 . 3, 1 . 2 . 4 . 5 . 9) = 4
    ---- 
	eq countCompromised(IL1, IL2) = countCompromised*(IL1, IL2, 0) .

	---- A helper (tail-recursive) function to countCompromised
	op countCompromised* : NatList NatList Nat -> [Nat] .
    ---- countCompromised*(IL1, IL2, N): 
    ----    IL1: The remaining list of indices (proposers) yet to be processed 
    ----    IL2: The reference list of indices (compromised validators)
    ----	N  : The current count of matching indices 
    ----    Result: Returns the number of indices in the first list that appear 
    ----            in the second (and hence the number of compromised validators
    ----            in the proposers list)
    ----    e.g.: countCompromised*(2 . 5 . 3 . 2 . 9 . 4, 1 . 2 . 4 . 5 . 9, 0) = 5
    ----    e.g.: countCompromised*(2 . 5 . 3 . 2 . 9 . 3, 1 . 2 . 4 . 5 . 9, 0) = 4
    ---- 
    ---- If an index match is found, increment the count (and remove the index from the first list)	
	eq countCompromised*((IL1 . I . IL1'), (IL2 . I . IL2'), N) 
	  = countCompromised*((IL1 . IL1'), (IL2 . I . IL2'), s(N)) .
	---- Otherwise, if no index matches, just return the current count 
	eq countCompromised*(IL1, IL2, N) = N [owise] .


    ---- Second scoring function: computing the longest compromised tail 
	op countCompromisedTail : NatList NatList -> [Nat] .
    ---- countCompromisedTail(IL1, IL2): 
    ----    IL1: A list of indices (the proposers list)
    ----    IL2: A list of indices (the compromised validator list)
    ----    Result: Returns the size of the longest (continuous) tail of indices  
    ----            in the first list that appears in the second (and hence the 
    ----            number of last validators that are compromised in the 
    ----            proposers list)
    ----    e.g.: countCompromisedTail(2 . 5 . 3 . 2 . 9 . 4, 1 . 2 . 4 . 5 . 9) = 3
    ----    e.g.: countCompromisedTail(2 . 5 . 3 . 2 . 9 . 3, 1 . 2 . 4 . 5 . 9) = 0
    ----
	eq countCompromisedTail(IL1, IL2) = countCompromisedTail*(IL1, IL2, 0) .

	---- A helper (tail-recursive) function to countCompromisedTail
	op countCompromisedTail* : NatList NatList Nat -> [Nat] .
    ---- countCompromisedTail*(IL1, IL2, N): 
    ----    IL1: The remaining list of indices (proposers) yet to be processed 
    ----    IL2: The reference list of indices (compromised validators)
    ----	N  : The current count of matching tail  indices 
    ----    Result: Returns the size of the longest (continuous) tail of indices  
    ----            in the first list that appears in the second (and hence the 
    ----            number of last validators that are compromised in the 
    ----            proposers list)
    ----    e.g.: countCompromisedTail*(2 . 5 . 3 . 2 . 9 . 4, 1 . 2 . 4 . 5 . 9, 0) = 3
    ----    e.g.: countCompromisedTail*(2 . 5 . 3 . 2 . 9 . 3, 1 . 2 . 4 . 5 . 9, 0) = 0
    ----
    ---- If the last index in the first list matches an index in the second, 
    ---- increment the count (and remove the index from the first list)	
	eq countCompromisedTail*((IL1 . I), (IL2 . I . IL2'), N) 
	  = countCompromisedTail*(IL1, (IL2 . I . IL2'), s(N)) .
	---- Otherwise, if the last index does not match any index in the second, 
	---- just return the current count 
	eq countCompromisedTail*(IL1, IL2, N) = N [owise] .

	---- A selector function to compute the score 
	op computeScoreFunction : Nat NatList NatList -> [Nat] .
	---- computeScoreFunction(I, IL, IL'):
	----    I:  The index of the score function to be used 
	----        0 for countCompromised
	----        1 for countCompromisedTail
	----    IL: The first list 
	----    IL: The second list 
	----    Result: Computes the score of IL and IL' based on the function index I 
    ----    e.g.: computeScoreFunction(0, 2 . 5 . 3 . 2 . 9 . 4, 1 . 2 . 4 . 5 . 9) = 5
    ----    e.g.: computeScoreFunction(1, 2 . 5 . 3 . 2 . 9 . 4, 1 . 2 . 4 . 5 . 9) = 3
    ----
    ---- The first scoring function: countCompromised
	eq computeScoreFunction(0, IL, IL') = countCompromised(IL, IL') .
	---- The second scoring function: countCompromisedTail 
	eq computeScoreFunction(1, IL, IL') = countCompromisedTail(IL, IL') .

	---- The length of a given list 
	op length : NatList -> [Nat] .
	---- length(IL):
	----    IL:  A list of nats 
	----    Result: The length of IL 
    ----
	eq length(nilIL) = 0 .
	eq length(I . IL) = s(length(IL)) .

	---- The set representation of a list of indices 
	op toNatSet : NatList -> [NatSet] .
	---- toNatSet(IL):
	----    IL:  A list of nats 
	----    Result: The set of indices corresponding to IL 
    ----
	eq toNatSet(nilIL) = mtIS .
	eq toNatSet(I . IL) = I , toNatSet(IL) .
endm


***( 
*** Attacker (Compromised) Validator Roles
***
*** This modules defines data structures specifying validator roles.
*** A validator role defines the behavior of a validator as a member
*** of the proposers list. A validator may be honest, in which case 
*** it behaves according to the protocol. A compromised validator may
*** assume one of three roles labeled: isolated, ctailhead and 
*** ctailtail, depending on its position in the proposers list. An 
*** isolated validator is one that does not belong to a compromised 
*** tail of the list. ctailhead and ctailtail are the validator roles 
*** for the head and the tail of the compromised tail. We give an
*** example below:
***  
*** Example 1: Assuming 3, 5, 7 and 9 are the only compromised 
***            validators, in the list of proposers 
***                       1 . 2 . 3 . 5 . 4 . 7 . 9
***            we have the following roles:
***            * 3 and 5 are isolated
***            * 7 is a ctailhead
***            * 9 is a ctailtail
***
*** Since a validator with role ctailhead will need the seeds of all
*** validators in the rest of the tail of the list (ctailtail validators),
*** the ctailhead role maintains this list of seeds as an argument (this
*** is another design for efficiency that is not strictly needed).
***
*** Finally, since the same validator may appear more than once in the 
*** proposers list, a validator may have more than one role. We therefore
*** index a role by the slot number for that role. For instance, in the 
*** example above, if the list was 1 . 2 . 7 . 5 . 4 . 7 . 9, validator 7
*** would have two roles (a role set): [3 : isolated] [6 : ctailhead].
)
mod ROLES is 
	protecting NATLIST .

	---- Compromised validator role positions: 
	---- constructers for isolated, ctailhead(IL) and ctailtail
	sort CPosition .
	ops isolated ctailtail : -> CPosition [ctor] .
	op  ctailhead : NatList -> CPosition [ctor] .

	---- Roles and Role Sets
	sort Role CRoleSet CRole .
	---- A 'Role' is a set of slot-indexed compromised
	---- roles 'CRoleSet'
	subsort CRoleSet < Role .
	---- A single 'CRole' is a (degenerate) instance of 'CRoleSet'
	subsort CRole < CRoleSet .

	---- A compromised role is a slot-indexed compromised role position 
	op [_:_] : Nat CPosition -> CRole [ctor].
	---- A set of compromised roles is constructed by mtCRS, for the empty
	---- set, and the associative commutative comma operator with id mtCRS
	op mtCRS : -> CRoleSet [ctor] .
	op _,_ : CRoleSet CRoleSet -> CRoleSet [ctor comm assoc id: mtCRS] .
endm


***( 
*** Validator Records
***
*** This modules defines validator records, which are data structures used 
*** to maintain details of validators needed for the proper execution of the 
*** protocol and the attacker. There are two types of validator records: 
*** (1) general validator records that maintain:
***		* The validator's (actor object) name
***		* The current-round seed
***     * The hash of the current seed 
***     * The next-round seed 
***     * The validator's profit (in Ether) 
*** (2) compromised validator records that maintain:
***		* The validator's (actor object) name
***     * The validator's role
***
*** While a general validator record exists for each validator, only 
*** compromised validators that are part of the proposers list in the
*** current round have compromised validator records as well.
)
mod VRECORD is
	protecting APMAUDE .
	protecting NATLIST .
	protecting ROLES .

	---- General validator record
	sort VRecord .
	---- A general validator record is a quintuple < A, S, H, S', N >, with
	---- 	A  the validator's name (identifier),
	----	S  its current-round seed,
	----	H  its hash, 
	---- 	S' the next-round seed, and 
	----	N  its net balance.
	op <_,_,_,_,_> : ActorName Seed Hash Seed Int -> VRecord [ctor] .

	---- General validator record list 
	sort VRecordList .
	---- A general record is a (singleton) list of records 
	subsort VRecord < VRecordList .
	---- A general validator record list is constructed by the empty
	---- record list nilVHL, or by the associative semi-colon operator
	---- on record lists, with nilVHL the identity element.
	op nilVHL : -> VRecordList [ctor] .
	op _;_ : VRecordList VRecordList -> VRecordList [ctor assoc id: nilVHL] .

	---- Compromised validator record
	sort CVRecord .
	---- A compromised validator record is a pair < A, R >, with A the 
	---- validator's name (identifier) and R its role.
	op <_,_> : ActorName Role -> CVRecord [ctor] .

	---- Compromised validator record list 
	sort CVRecordList .
	---- A compromised record is a (singleton) list of records 
	subsort CVRecord < CVRecordList .
	---- A compromised validator record list is constructed by the empty
	---- record list nilCVL, or by the associative semi-colon operator
	---- on record lists, with nilCVL the identity element.
	op nilCVL : -> CVRecordList [ctor] .
	op _;_ : CVRecordList CVRecordList -> CVRecordList [ctor assoc id: nilCVL] .
endm

***( 
*** Proposer Records
***
*** This modules defines proposer records maintained by the RANDAO object.
*** These are simple data structures used to record whether a proposer 
*** managed to successfully propose a valid block and reveal its seed. 
*** A proposer record is a pair [A, B], with A the proposers name, and B
*** a boolean flag indicating whether A successfully revealed its seed. 
***
)
mod PRECORDS is
	protecting APMAUDE .

	---- Proposer record 
	sort PRecord .
	---- A proposer record is a pair [A, B], with A the proposers name, and B
	---- a boolean flag indicating whether A successfully revealed its seed.	
	op [_,_] : ActorName Bool -> PRecord [ctor] .
	
	---- Prposer record list 
	sort PRecordList .
	---- A proposer record is a (singleton) list of records 
	subsort PRecord < PRecordList .
	---- A proposer record list is constructed by the empty
	---- record list nilPL, or by the associative semi-colon operator
	---- on record lists, with nilPL the identity element.
	op nilPL : -> PRecordList [ctor] .
	op _;_ : PRecordList PRecordList -> PRecordList [ctor assoc id: nilPL] .
endm

***(
*** Attack strategies
***  
*** This module defines data structures and operations for specifying
*** attack strategies for compromised validators appearing in the proposers
*** list's compromised tail (the ones with roles ctailhead and ctailtail). 
*** An attack strategy is a pair [G : S], where G is the index identifying the
*** strategy and S is its resulting seed. G instructs validators in the
*** compromised tail to either reveal or skip their turns in a round of the 
*** game. Although G is a natural number, the binary representation of the 
*** index G precisely defines the strategy (1 means reveal and 0 means do not
*** reveal). For example, the strategy indexed 6 (in binary 6 = 110) states
*** that the first validator skip (the 0 in 110) and the following 
*** two validators should reveal (the two 1's in 110). Note that the binary
*** string is read in reverse (the head of the validator list corresponds to
*** the least significant binary digit). This provides a compact representation 
*** of strategies that is easy to compute and read. 
*** 
*** Note that:
*** 1. the remainder operation G rem 2 gives the current strategy action
*** 2. the integer quotient G quo 2 returns the rest of the strategy
***
*** The seed S is what one would get if the strategy specified by G was applied
*** to a given initial seed (the RANDAO computed seed). An attacker may 
*** pre-compute a set of strategies to decide the best attack strategy given  
*** the current circumstances. 
***
)
mod STRATEGY is
	protecting HASH .

	---- Attack strategy 
	sort Strategy .
	---- A strategy is a pair [G : S], with G the strategy's index (its 
	---- representation as a non-negative integer in binary) and S the seed
	---- that results from applying G
	op [_:_] : Nat Seed -> Strategy .

	---- Sets of strategies 
	sort StrategySet .
	---- A strategy is a singleton strategy set 
	subsort Strategy < StrategySet .
	---- A strategy set is constructed by the associative and commutative 
	---- empty juxtaposition operator on strategy sets. Note this set cannot 
	---- be empty!
	op __ : StrategySet StrategySet -> StrategySet [assoc comm] .
endm


***(
*** Actor Names
***  
*** This module defines the actor names of the actor objects that could 
*** appear in a configuration. There are five actors in total:
***   v(I) : a validator with index I 
***   bc   : the blockchain actor (modeling the state of the protocol)
***   r    : the RANDAO contract actor 
***   a    : the attacker actor 
***   g    : the validator generator actor (for modeling a dynamic validator set)
*** 
*** We note that, for execution efficiency, a validator actor v(I) is not  
*** represented by its own actor object, but rather by its validator records
*** stored in other objects (bc and a).  					
)
mod OBJECTS is 
	extending APMAUDE .
    op v  : Nat -> ActorName .   --- Validators
    op bc :     -> ActorName .   --- Blockchain 
    op r  :     -> ActorName .   --- RANDAO Contract
    op a  :     -> ActorName .   --- Attacker
    op g  :     -> ActorName .   --- Validator Generator
endm

***(
*** Actor attributes
***  
*** This module defines all attributes that may be part of an actor object
*** in the specification. An attribute is a key-value pair that records
*** important information about the state of an actor. Note that the same  
*** attribute may appear in more than one actor type.
***   	
*** Below, we list the attributes of each actor object:
***
*** Blockchain:
***		<name: bc |					---- The Blockchain Object
***			seed:           S,  	---- seed of previous game round
***			vpending:       VHL,    ---- list of records of pending validators 
***			vpending-size:  N,      ---- their count
***			vapproved:      VHL',   ---- list of records of approved validators  
***			vapproved-size: N'      ---- their count
***		> .
***
*** RANDAO Contract:
***		<name: r |					---- the RANDAO Contract
***			status:         U,      ---- status can be 'ready' or 'processing' 
***			balance:        N,      ---- current contract balance 
***			success-rounds: J,      ---- number of successful rounds
***			precords:       PL, 	---- proposers participating in the current game round
***			prop-size:      M,      ---- their count (in the steady state, this must be equal to #CYCLE-LENGTH)
***			prop-ilist: 	IL, 	---- their indices,       
***			pnext:          I       ---- next validator (time slot) to process
***		> .
***
*** Attacker:
*** 	<name: a |					---- the Attacker Object
***			vcomp:			CVL,	---- compromised validator records
***			vcomp-ilist:	IL,		---- a list of the compromised validator indices
***			vcomp-size:		N,      ---- the size of IL
***			strategy:		G		---- the attacker's strategy (for tails controlled by the attacker)
***		> .	
***
***	Validator Generator: 
***		<name: g | 					---- the validator generator 
***			vcount: N, 				---- the index of the next validator to be generated 
***			contract: RID,			---- the name of the RANDAO contract 
***			next-seed: S,			---- the seed of the next validator to be generated
***			next-comp: B > .		---- a Boolean indicating whether the next validator is compromised or not 
***
)
mod ATTRIBUTES is
    protecting VRECORD .
    protecting PRECORDS .
    protecting NATLIST .
    protecting STRATEGY .

    --- states of an actor
    sort Status .
    ops processing ready : -> Status . 

    --- Attributes (as explained above)
    op status:_         : Status		-> Attribute [format (m o d)] .  
    op balance:_        : Nat			-> Attribute [format (m o d)] .  
    op seed:_           : Seed			-> Attribute [format (m o d)] .
    op vapproved:_      : VRecordList 	-> Attribute [format (m o d)] .
    op vapproved-size:_ : Nat			-> Attribute [format (m o d)] .
    op vpending:_       : VRecordList	-> Attribute [format (m o d)] .
    op vpending-size:_  : Nat			-> Attribute [format (m o d)] .
    op precords:_       : PRecordList	-> Attribute [format (m o d)] .
    op prop-ilist:_     : NatList		-> Attribute [format (m o d)] .
    op prop-size:_      : Nat			-> Attribute [format (m o d)] .
    op pnext:_          : Nat 			-> Attribute [format (m o d)] .
    op success-rounds:_ : Nat			-> Attribute [format (m o d)] .
    op contract:_       : ActorName 	-> Attribute [format (m o d)] .
    op next-seed:_      : Seed 			-> Attribute [format (m o d)] .
    op vcomp:_ 			: CVRecordList	-> Attribute [format (m o d)] .
    op vcomp-ilist:_ 	: NatList 		-> Attribute [format (m o d)] .
    op vcomp-size:_     : Nat			-> Attribute [format (m o d)] .
    op strategy:_ 		: Nat 			-> Attribute [format (m o d)] .
    op vcount:_ 		: Nat 			-> Attribute [format (m o d)] .
    op next-comp:_ 		: Bool 			-> Attribute [format (m o d)] .
endm


***(
*** Message Content
***
*** This module defines message contents (payload) that could potentially be 
*** used in messages exchanged between actors of the system. Recall that a
*** message has the form (A <- C), where A is the target actor and C is the 
*** content of the message, which we define here. 
***    
)
---- Message contents
mod MESSAGES is
    protecting VRECORD .
    protecting PRECORDS .
   	extending APMAUDE .

	---- Message Contents:

	---- reveal(A, S, H): A reveal by actor A of the seed S while  
	---- committing to the next seed using H 
	op  reveal 		: ActorName Seed Hash 	-> Content .

	---- nextSlot(K): schedule advancing the process to the next slot
	---- (used in self-addressed messages) 
	op  nextSlot 	: Nat  					-> Content . 

	---- nextRound(): schedule advancing the process to the next round 
	---- (used in self-addressed messages) 
	op  nextRound 	:   					-> Content . 
 
	---- doReveal(X, K): assign a possible reveal action at slot K 
	---- 				where X is 0 for an honest validator and 1 
	---- 				for a compromised validator
	op  doReveal	: Nat Nat				-> Content . 

	--- spawn(): schedule arrival of the next validator to the system 
	---- (used in self-addressed messages when dynamic validators are 
	---- assumed) 
	op  spawn		:						-> Content . 
endm

***(
*** Actor Configuration
***
*** This module defines additional configuration components (in addition
*** to actors, messages and the scheduler which were defined in a previous
*** module).  
***    
)
---- Configuration 
mod CONFIG is
	protecting ATTRIBUTES .
	protecting OBJECTS .
	protecting MESSAGES .
	protecting NATLIST .

    --- Additional configuration fields

    ---- limit(B, F): A control device that allows us to specify the length
    ---- of a simulation run (the macro step captured by 'tick')
    op limit : Bool Float -> Config [format (nb! o)] .

endm


***(
*** RANDAO Actions
***
*** This module defines how the RANDAO actor behaves. Behavior is 
*** captured by rewrite rules specifying transitions in the system.
*** There are three transitions:
*** 1. RAdvanceSlot: which advances the process to the next slot
*** 2. RAdvanceRound: which advances the process to the next round
*** 3. RProcessReveal: which processes a reveal message from a proposer
***    
*** The module also defines other operations needed for the 
*** specification of these transitions.
***
)
mod RANDAO-BEHAVIOR is
	protecting CONFIG .
	protecting PARAMS .

	---- All variable declarations
	vars S S' S'' RS 				: Seed .
	vars AS AS' AS'' 				: AttributeSet . 
	vars T TG TS TS' TR TR' D R F 	: Float .
	vars SL SL' 					: ScheduleList . 
	vars ST ST' 					: Strategy .
	vars SSTS STS STS' 				: StrategySet .
	vars CID VID RID OID AID BID 	: ActorName .
  	vars H H' 						: Hash .
	vars I J K L M M' N N' G G'     : Nat .
	vars VHL VHL'                   : VRecordList .
	vars CVL CVL'                   : CVRecordList .
	vars CL                         : PRecordList .
	vars B B' T?                    : Bool .
	vars IL IL' IL1 IL1' IL2 IL2'   : NatList .
	vars X                          : Int .
	vars RO                         : Role .
	vars CRS                        : CRoleSet . 
	vars SDL                        : NatList .
	vars IS                         : NatSet .

	*******************************************
	**** Further Operations Needed by the Rules
	******************************************* 

	---- Make a list of (empty) compromised validator records 
	op makeCVL : NatList NatList -> [CVRecordList] .
	---- makeCVL(IL, IL'): 
	----	IL : A nat list (list of proposer indices)
	----	IL': A nat list (list of attacker indices)
	---- 	Result: A list of compromised validator records for compromised 
	----    		validators appearing in IL 
	----
	---- e.g. makeCVL( 0 . 1 . 2 . 3 . 2,  0 . 2 . 4) rewrites to
	---- 		< v(0), mtCRS > ; < v(2), mtCRS >
	---- 
	---- Convert the list of proposers to its corresponding set and
	---- then call the helper function makeCVL*. A validator cannot
	---- have more than one compromised record in the resulting list.   
	eq makeCVL(IL, IL') = makeCVL*(toNatSet(IL), IL') .

	---- A helper operator for makeCVL above 
	op makeCVL* : NatSet NatList -> [CVRecordList] .
	---- makeCVL*(IS, IL'): 
	----	IS : A nat set (set of proposer indices)
	----	IL': A nat list (list of attacker indices)
	---- 	Result: A list of compromised validator records for compromised 
	----    		validators appearing in IS 
	----
	---- e.g. makeCVL*( (0,1,2,3),  0 . 2 . 4) rewrites to
	---- 		< v(0), mtCRS > ; < v(2), mtCRS >
	---- 	
	---- If the set is empty, return the nil list of records 
	eq makeCVL*(mtIS, IL') = nilCVL .
	---- If an index in the set matches another in the list, create a record 
	---- and proceed with the rest of the set 
	eq makeCVL*((I , IS), (IL1 . I . IL1')) 
		=  makeCVL*(IS, (IL1 . I . IL1')) ; < v(I), mtCRS > .
 	---- Otherwise, if no match exists, return the nil list 
   eq makeCVL*((I , IS), IL')
		=  nilCVL [owise] . 

	---- Updating validator records for successful reveals 
    op updateRewards : VRecordList PRecordList -> [VRecordList] .
	---- updateRewards(VHL, CL) 
	----    VHL: list of validator records 
	----    CL : list of proposer records 
	----    Result: The validator records list VHL where each successful reveal 
	----            is rewarded by increasing the corresponding validator balance.
	----            Whether a reveal was successful is given by the appropriate 
	----            record in CL.
	---- Note 1: Rewarding means adding 2 Ether to the validator record balance
	---- Note 2: This is so far unused (but could be built on in a future version)
	----
	---- e.g. updateRewards(< v(0), S, H, S', 10 >, [v(0) , true])  = < v(0), S, H, S', 12 >
	---- e.g. updateRewards(< v(0), S, H, S', 10 >, [v(0) , false])  = < v(0), S, H, S', 10 >
	----
	---- If the list of proposer records is nil, return the nil validator record list  
    eq updateRewards(VHL, nilPL) 
    	= VHL . 
	---- If not, use the first proposer record's Boolean flag to update the corresponding validator
	---- record and repeat the process for the remaining proposer records  
    eq updateRewards((VHL ; < v(I), S, H, S', X > ; VHL'), [ v(I) , B' ] ; CL) 
    	= updateRewards((VHL ; < v(I), S, H, S', (if B' then X + 2 else X fi) > ; VHL'), CL) .

    ---- Creating initial proposer records 
    op makePropRecords : NatList -> [PRecordList] .
	---- makePropRecords(IL) 
	----    IL: list of proposer indices 
	----    Result: The list of proposer records corresponding to IL, where 
	----            the reveal status is initialized to false.
	----
	---- e.g. makePropRecords(1 . 0)
	----         = [v(1) , false] ; [v(0), false]
	----
	---- If the list is nil, return the nil proposer record list  
    eq makePropRecords(nilIL) = nilPL . 
	---- Otherwise, create a proposer record for the first index, and recursively
	---- repeat the process for the remaining indices   
    eq makePropRecords(I . IL) = [ v(I) , false ] ; makePropRecords(IL) .

    ---- Assign roles to compromised validators 
    op setNewCVRoles : CVRecordList NatList VRecordList -> [CVRecordList] .
    ---- setNewCVRoles(CVL, IL)
    ----	CVL: list of (compromised) validator records 
    ----	IL : list of proposer indices 
 	----    VHL: list of validator records 
    ----	Result: The list of (compromised) validator records CVL in which 
    ----		the roles of the validators appearing in IL are appropriately
    ----        set according to the validator type and position in IL 
    ----
    ---- e.g. Assuming CYCLE-LENGTH = 3, we have 
	----    setNewCVRoles(< v(0) , mtCRS > ; < v(1), mtCRS > , 
	----                  0 . 1 . 2 , 
	----                  < v(0), S0:Seed, H0:Hash, S0':Seed, X0:Int > ; 
	----                  < v(1), S1:Seed, H1:Hash, S1':Seed, X1:Int > ; 
	----                  < v(2), S2:Seed, H2:Hash, S2':Seed, X2:Int >)    
	----		  = < v(0),[1 : isolated] > ; < v(1),[2 : isolated] >
	----
    ---- e.g. Assuming CYCLE-LENGTH = 5, we have 
    ----	setNewCVRoles(< v(0) , mtCRS > ; < v(1), mtCRS > , 
    ----                  0 . 1 . 2 . 0 . 1, 
    ----                  < v(0), S0:Nat, H0:Hash, S0':Nat, X0:Int > ; 
    ----                  < v(1), S1:Nat, H1:Hash, S1':Nat, X1:Int > ; 
    ----                  < v(2), S2:Nat, H2:Hash, S2':Nat, X2:Int >)
    ----		  = < v(0),[1 : isolated],[4 : ctailhead(S0:Nat . S1:Nat)] > ; 
    ----            < v(1),[2 : isolated],[5 : ctailtail] >
    ----
    eq setNewCVRoles(CVL, IL, VHL) = setNewCVRoles*(CVL, IL, VHL, #CYCLE-LENGTH, true, nilIL) .

    ---- A helper function to assign roles to compromised validators
    op setNewCVRoles* : CVRecordList NatList VRecordList Nat Bool NatList -> [CVRecordList] .
    ---- setNewCVRoles*(CVL, IL, N, B, SDL)
    ----	CVL: list of (compromised) validator records 
    ----	IL: list of proposer indices 
 	----    VHL: list of validator records 
    ----	N: A natural number (the remaining records in the proposers list) 
    ----	B: A Boolean indicating whether an honest validator has been seen so far
    ---- 	SDL: The list of seeds of the compromised tail of IL collected so far     
    ----	Result: The list of (compromised) validator records CVL in which 
    ----		the roles of the validators appearing in IL are appropriately
    ----        set according to the validator type and position in IL 
    ---- This is a helper function to setNewCVRoles
    ----
    ---- If the index list is nil, return the current compromised validator records
    eq setNewCVRoles*(CVL, nilIL, VHL, N, B, SDL) 
    	=  CVL . 
    ---- If the index list is not nil, 
    ----   and the next index I matches a compromised record, 
    ----   and we have already seed an honest validator index 
    ---- Then update the compromised validator record with the 'isolated' role for the current slot number  
    eq setNewCVRoles*((CVL ; < v(I) , CRS > ; CVL'), (IL . I), VHL, s(N), false, SDL) 
    	= setNewCVRoles*((CVL ; < v(I) , (CRS , [s(N) : isolated]) > ; CVL'), IL, VHL, N, false, SDL) .
    ---- If the index list is not nil, 
    ----   and the next index I matches a compromised record, 
    ----   and we haven't yet seed an honest validator index 
    ---- Then update the compromised validator record with either 'ctailhead' or 'ctailtail' role for the 
    ---- current slot number depending on whether the next-in-line validator is compromised or not  
   ceq setNewCVRoles*((CVL ; < v(I) , CRS > ; CVL'), (IL . I), (VHL ; < v(I), S, H, S', X > ; VHL'),  s(N), true, SDL) 
    	= if B then 
    		---- The following validator is compromised, so the current validator is ctailtail
    		setNewCVRoles*((CVL ; < v(I) , (CRS , [s(N) : ctailtail]) > ; CVL'), IL, (VHL ; < v(I), S, H, S', X > ; VHL'),  N, true, (S . SDL)) 
    	  else
    		---- The following validator is honest, so the current validator is the head of the tail 
    		setNewCVRoles*((CVL ; < v(I) , (CRS , [s(N) : ctailhead(S . SDL)]) > ; CVL'), IL, (VHL ; < v(I), S, H, S', X > ; VHL'),  N, true, (S . SDL)) 
    	  fi
    	if B := compEnd?((CVL ; < v(I) , CRS > ; CVL'), IL) .
    ---- If the index list is not nil, 
    ----   and the next index I does not match a compromised record, 
    ---- then ignore this index and record the fact that we have seed an honest validator index 
    eq setNewCVRoles*(CVL, (IL . I), VHL, s(N), T?, SDL) = setNewCVRoles*(CVL, IL, VHL, N, false, SDL) [owise] .

    ---- Checking whether the last index in a list is for a compromised validator 
    op compEnd? : CVRecordList NatList -> [Bool] .
    ---- compEnd?(CVL, IL)
    ----	CVL: list of (compromised) validator records 
    ----    IL : list of proposer indices
    ----    Result: A Boolean indicating whether the end of IL is compromised
    ---- This is a helper function to setNewCVRoles*
    ---- 
    ---- If the end matches a compromised record, return true 
    eq compEnd?((CVL ; < v(I) , CRS > ; CVL'), (IL . I)) = true .
    ---- Otherwise, return false 
    eq compEnd?(CVL, IL) = false [owise] .

    ---- Creating a list of scheduled doReveal messages assigning time slots to proposers 
    op createDoReveals : Float ActorName Nat NatList NatList -> [ScheduleList] .
	---- createDoReveals(F, A, N, IL, IL')
    ----	F: the global time value 
    ---- 	A: the RANDAO contract actor name (not really used in this version)
    ----    N : a counter representing the number of messages created so far 
    ----    IL: list of validator indices (target validators)
    ----    IL': list of compromised validator indices
    ----    Result: A list of scheduled doReveal messages targeted at validators  
    ---- 			in IL with base time value TG 
    ---- 
    ---- e.g. createDoReveals(0.0, r, 3, (2 . 5 . 7), (2 . 7)) may rewrite to:
    ---- 			[0.0260136714847790, v(2) <- doReveal(1, 1), 0] ; 
    ----            [1.0773220517922477, v(5) <- doReveal(0, 2), 0] ; 
    ----            [2.0658048222786292, v(7) <- doReveal(1, 3), 0]
    ----
    ---- If the list of target validators is nil, return the nil scheduled messages list      
    eq createDoReveals(TG, RID, N, nilIL, IL') = nil .
    ---- If the list is not nil, and the next index I matches a compromised index, then
    ---- add a scheduled message for I (as a compromised validator) and proceed with the rest
    eq createDoReveals(TG, RID, N, I . IL, (IL1 . I . IL1')) 
      = [TG + float(N) + #TRANSMISSION-DELAY, (v(I) <- doReveal(1, s(N))), #MSG-DROP-PROB] ; 
        createDoReveals(TG, RID, s(N), IL, (IL1 . I . IL1')) .
    ---- If the list is not nil, and the next index I does not match a compromised index, then
    ---- add a scheduled message for I (as an honest validator) and proceed with the rest
    eq createDoReveals(TG, RID, N, I . IL, IL') 
      = [TG + float(N) + #TRANSMISSION-DELAY, (v(I) <- doReveal(0, s(N))), #MSG-DROP-PROB] ; 
        createDoReveals(TG, RID, s(N), IL, IL') [owise] .

    ---- Checking whether the entire list of proposer indices is compromised 
    op allCompromised? : NatList NatList -> [Bool] .
	---- allCompromised(IL, IL')
    ----    IL : list of indices (proposers)
    ----    IL': list of indices (compromised validator indices)
    ----    Result: true if all indices are compromised, false otherwise 
    ----
    ---- If the proposers list is nil, then true (all are vacuously compromised)
    eq allCompromised?(nilIL, IL) = true .
    ---- If not, and the next index matches a compromised index, then return the result
    ---- of recursively checking the rest of the list 
    eq allCompromised?(I . IL, IL1 . I . IL2) 
    	= allCompromised?(IL, IL1 . I . IL2) .
   	---- If not, and there is no match, return false immediately (we found an honest index) 
    eq allCompromised?(I . IL, IL') = false [owise] .


	****************************************
	**** The Rules
	**************************************** 

	---- RAdvanceSlot: Advance the process to the next slot
	---- This rule processes a message of the form nextSlot(L), which initiates
	---- the process of advancing the state of the protocol to the next slot. 
	---- Assuming K is the next slot number to be processed as recorded in the
	---- state of the RANDAO contract object, there are three cases:
	---- Case 1: L > #CYCLE-LENGTH, which means that the protocol has already
	----	processed the end of the #CYCLE-LENGTH proposers for the current 
	----    round, and progressing to the next slot would require advancing the
	----    the current round of the game first. The RANDAO contract object 
	---- 	changes its status to 'processing', samples a new proposers list
	---- 	using its stored computed seed, and resets the slot count back to 1. 
	---- 	It also emits a zero-delay 'nextRound' message to continue its 
	----    preparation for the following round of the game. 
	---- Case 2: L == K, which means that slot number was already advanced by
	---- 	successfully processing a reveal. In this case, the state is not
	---- 	changed and a 'nextSlot' message is scheduled as normal.
	---- Case 3: L > K, which means the slot number was not advanced before
	----	and thus, either a reveal was attempted but failed or that a reveal
	----    was never received. In both cases, the RANDAO object records that 
	----	as a failure in the proposers record list and advances the slot 
	----	number. It also schedules a 'nextSlot' message for the next slot. 
	----
 rl [RAdvanceSlot] :
 	limit(true, D)
 	<name: BID |		
			seed:			S, 
			vapproved-size: N,
			vpending-size:	N',
			AS >
 	<name: RID |		
			status:		ready, 
			precords:	([ VID , B ] ; CL),
			prop-ilist: IL,       
			pnext: 		K,
			AS' >
    { TG | SL }
    (RID <- nextSlot(L))
    =>  ---- Update the simulation Boolean flag
    	limit(TG <= #SIM-TIME-LIMIT * D, D)
    	---- The blockchain object remains the same 
    	<name: BID |		
				seed:           S, 
				vapproved-size: N,
				vpending-size:	N',
				AS >
		---- The RANDAO object checks L 
    	if L > #CYCLE-LENGTH then
    		---- End of game round: prepare to advance to the next round 
 			<name: RID |		
					status: 	processing, 
					precords:	([ VID , B ] ; CL),
					--- Begin sampling the next-round list of proposer indices       
					prop-ilist: sampleIndexList(N + N', #CYCLE-LENGTH, S),       
					pnext:	 	1,
					AS' >
    		{ TG | SL }
    		---- Emit a no-delay nextRound message to continue moving to the next round 
    		(RID <- nextRound)
    	else 
    		if L == K then 
    			---- Slot was already advanced by a valid reveal -- so no changes 
 				<name: RID |		
						status:		ready, 
						precords:	([ VID , B ] ; CL),       
						prop-ilist: IL,       
						pnext:		K,
						AS' >
			else
				---- Slot was not advanced -- advance it and record failure of a reveal
 				<name: RID |		
						status:	ready, 
						precords:	(CL ; [ VID , false ]),       
						prop-ilist: IL,       
						pnext:	s(K),
						AS' >
			fi 
			---- In both cases, schedule the next time slot check 
			mytick(insert({ TG | SL }, [floor(TG) + 1.0, (RID <- nextSlot(s(L))), 0])) 
		fi
    	[print TG ": RAdvanceSlot: from " K " to " L] .

    ---- RAdvanceRound: Advance the process to the next round 
    ---- This rule processes a 'nextRound' message. Several steps are taken in this 
    ---- transition:
    ---- 1. The validator records VHL are updated to reward those who have 
    ----    successfully reveled their seeds in the last round (with updateRewards).
    ---- 2. The pending validators list VHL' is incorporated into the approved list
    ----    in preparation for their participation in the next round and the list 
    ----    sizes are updated accordingly.
    ---- 3. Given the freshly sampled list of proposer indices IL, the list of (compromised)
    ----    validator records for the compromised validators are updated with 
    ----    potentially new attacker roles (with setNewCVRoles).  
    ---- 4. Given the freshly sampled list of proposer indices IL, a new proposers
    ----    list is created and initialized (with makePropRecords) 
    ---- 5. A new list of 'doReveal' messages is created and inserted into the 
    ----    scheduler, along with a 'nextSlot' message to resume advancing rounds.
    ----
  rl [RAdvanceRound] :
 	limit(true, D)
 	<name: BID |		
			vapproved: 		VHL,
			vapproved-size: N,
			vpending:		VHL',
			vpending-size:	N', 
			AS >
	<name: a   |
			vcomp: 			CVL,
			vcomp-ilist:	IL',
			AS' >
 	<name: RID |		
			status:			processing, 
			balance: 		J,
			success-rounds: I, 
			precords:      CL,
			prop-ilist:		IL, 
			prop-size:     	M,
			pnext:          K,
			AS'' >
    { TG | SL }
    (RID <- nextRound)
    =>  ---- Update validator records and include pending validators 
	 	<name: BID |		
				vapproved: 		(updateRewards(VHL, CL) ; VHL'), 
				vapproved-size:	(N + N'),
				vpending:		nilVHL,
				vpending-size:	0, 
				AS >
		---- Create new compromised validator records with new roles 
		<name: a   |
				vcomp: 			setNewCVRoles(makeCVL(IL, IL'), IL, (VHL ; VHL')),
				vcomp-ilist:	IL',
				AS' >
		---- Create initial proposer records and reset next-round counter to 1
 		<name: RID |		
				status:			ready, 
				balance: 		J,
				success-rounds: s(I), 
				precords: 		makePropRecords(IL),
				prop-ilist:		IL, 
				prop-size:     	M,
				pnext:          1,
				AS'' >
		---- This is just an optimization: if the entire proposers list is compromised,
		---- there is no point in continuing this simulation.. The attacker has already 
		---- gained complete control of the network 
		if allCompromised?(IL,  IL') then 
			---- All compromised: so stop the simulation 
    		limit(false, D)
    		{ TG | SL }
    	else
    		---- Not all are compromised so proceed normally (update the simulation 
    		---- controller and schedule doReveal messages)
    		limit(TG <= #SIM-TIME-LIMIT * D, D)
    		mytick(insertList(insert({ TG | SL }, [floor(TG) + 1.0, (RID <- nextSlot(2)), 0]), createDoReveals(TG, RID, 0, IL, IL'))) 
    	fi
    	[print TG ": RAdvanceRound with new committee " IL] .


    ---- RProcessReveal: Process an incoming reveal message 
    ---- This rule processes a 'reveal' message sent by a proposer. There are
    ---- two cases:
    ---- 1. The reveal is successful (the commit check is successful), in which
    ----    case (1) the new seed is computed (using combineSeeds which XORs the 
    ----    currently stored seed with the revealed seed), (2) the fact that the 
    ----    reveal was successful is recorded in the proposers record, and (3)
    ----    the slot counter is incremented. 
    ---- 2. The reveal is not successful, in which case the failure is recorded
    ----    int the proposers record list.
    ---- In both cases, no new message is scheduled.
    ----
 rl [RProcessReveal] :
 	limit(true, D)
 	<name: BID |		
			seed:		RS,  
			vapproved: 	(VHL ; < VID, S, H, S', X > ; VHL') ,   
			AS >
 	<name: RID |		
			status:		ready, 
			precords:	([ VID , B ] ; CL),       
			pnext:		J,
			AS' >
    { TG | SL }
    (RID <- reveal(VID, S'', H'))
    =>  ---- Update the simulation Boolean flag
    	limit(TG <= #SIM-TIME-LIMIT * D, D)
    	---- Check the reveal 
    	if (H == h(S'')) then 
    		---- The reveal is successful, so update the seed 
		 	<name: BID |		
					seed:		combineSeeds(RS, S),  
					vapproved:	(VHL ; < VID, S, H', S', X > ; VHL') ,   
					AS >
			---- And record success and increment the slot number 
 			<name: RID |		
					status:		ready, 
					precords:	(CL ; [ VID , true ]),       
					pnext:		s(J),
					AS' >
		else
    		---- The reveal failed, so the seed does not change 
		 	<name: BID |		
					seed:		RS,  
					vapproved:	(VHL ; < VID, S, H, S', X > ; VHL') ,   
					AS >
			---- And record failure and keep the slot number counter 
 			<name: RID |		
					status:		ready, 
					precords:	(CL ; [ VID , false ]),       
					pnext:		J,
					AS' >
		fi 
    	mytick({ TG | SL }) 
    	[print TG ": RProcessReveal received from " VID] .
endm
 
***(
*** Validator Actions
***
*** This module defines how the validators (both honest and compromised) behave. 
*** There are essentially two validator actions, which we specify here using a 
*** total of 5 rules to maintain clarity of presentation (2 rules would 
*** technically be sufficient, but would result in structurally complicated rules).
*** 1. Revealing a seed: specified by 
***		- VHonestReveal: for honest validators
***     - VCompReveal1: for compromised validators with role 'isolated'
*** 	- VCompReveal2: for compromised validators with role 'ctailtail'
*** 	- VCompReveal3: for compromised validators with role 'ctailhead'
*** 2. Arriving to the system: specified by 
***		- VArrive
***
)
mod VALIDATOR-BEHAVIOR is
	protecting CONFIG .
	protecting PARAMS .

	---- All variable declarations
	vars S S' RS PS : Seed .
	vars AS AS' AS'' : AttributeSet . 
	vars T TG TS TS' TR TR' D R F : Float .
	vars SL SL' : ScheduleList . 
	vars CID VID RID OID AID BID VGID : ActorName .
  	vars H : Hash .
	vars I J K L M M' N N' G G' C C' : Nat .
	vars VHL VHL' : VRecordList .
	vars CVL CVL' : CVRecordList .
	vars CL : PRecordList .
	vars B : Bool .
	vars IL IL' IL1 IL1' : NatList .
	vars X : Int .
	vars RO : Role .
	vars CRS : CRoleSet . 
	vars ST ST' : Strategy .
	vars SSTS STS STS' : StrategySet .
	vars CP : CPosition .
	vars SDL : NatList .

	****************************************
	**** Some Operations Needed by the Rules
	**************************************** 

	---- Creating a set of strategies for a given list length and a starting seed 
	op createStratSet : Nat Seed NatList -> [StrategySet] .
	---- createStratSet(K, RS, SDL)
    ----	K:	The length of the remaining list for which strategies are to be computed 
    ---- 	RS: The current seed with which other seeds are to be combined 
    ----    SDL: The remaining list of seeds  
    ----    Result: The set of strategies corresponding to the length K and the seed RS 
    ---- 
    ---- e.g. createStratSet(2, 87863, 98753 . 17379) rewrite to:
    ---- 			[0 : 87863] [1 : 55030] [2 : 70868] [3 : 38165]
    ----
    ---- If the length K is exactly 1, return the two possible strategies (skip or reveal) 
	eq createStratSet(s(0), RS, S) = [0 : RS] [1 : combineSeeds(RS, S)] .
    ---- If the length is K > 1, 
    ---- compute recursively the strategies for K - 1 (named STS in the equation), and then 
    ---- take the union of STS with STS augmented with reveal decisions for the Kth seed.
	ceq createStratSet(s(s(K)), RS, (SDL . S))
		= STS augment1(STS, S, s(K))
		if STS := createStratSet(s(K), RS, SDL) .


	---- A helper function to createStratSet: Augment strategies with reveal decisions  
	op augment1 : StrategySet Seed Nat -> [StrategySet] .
	---- augment1(STS, S, K)
    ----    STS: The set of strategies to be augmented 
    ---- 	S  : The seed with which to augment strategies  
    ----	K  : The length at which augmentation is going to be applied 
    ----       (the position in the binary representation of a strategy)
    ----    Result: The set of strategies STS augmented with reveal decisions at length K
    ----            using the seed S 
    ---- 
    ---- e.g. augment1([0 : 87863] [1 : 55030] [2 : 70868] [3 : 38165], 98753, 2) rewrite to:
    ---- 			[4 : 55030] [5 : 87863] [6 : 38165] [7 : 70868]
    ----
    ---- If there is only one strategy, augment it 
    ---- Note that augmenting means adding a '1' to the left of the most significant digit of
    ---- the binary representation of the strategy G by taking 2 ^ K + G, and updating the seed 
	eq augment1([G : RS], S, K) 	= [2 ^ K + G : combineSeeds(RS, S)] .
    ---- If one or more strategies, augment the first strategy and proceed with augmenting the rest 
	eq augment1([G : RS] STS, S, K) = [2 ^ K + G : combineSeeds(RS, S)] augment1(STS, S, K) .

	---- Computing the score of a seed 
	op computeScore : Seed Nat Nat NatList -> [Nat] .
	---- computeScore(S, N, M, IL)
    ---- 	S  : The seed with which sampling is to be computed  
    ----	N  : The total size of the validator list  
    ----	M  : The length of the proposers list   
    ----	IL : The list of compromised validators    
    ----    Result: The score (given by the score function determined by #SCORE-FUNCTION) of the 
    ----            seed S 
    ---- 
    ---- e.g. assuming #SCORE-FUNCTION = 1, then 
    ----      computeScore(5439045, 100, 10, 0 . 7 . 20 . 35 . 41 . 52 . 69 . 71 . 87 . 90) 
    ----      rewrites to 1
    ----
    ---- The definition uses the operator computeScoreFunction defined way before
	eq computeScore(S, N, M, IL) 
	 	= computeScoreFunction(
					#SCORE-FUNCTION, 
					sampleIndexList(N, M, S),
					IL) .

	---- Find a strategy with a maximum score 
	op findMaxScoreStrat : StrategySet Nat Nat NatList -> [Nat] .
	---- findMaxScoreStrat(STS, N, M, IL)
    ---- 	STS: The set of strategies to be processed  
    ----	N  : The total size of the validator list  
    ----	M  : The length of the proposers list   
    ----	IL : The list of compromised validators    
    ----    Result: The strategy encoding of a maximum-score strategy in STS 
    ---- 
    ---- e.g. assuming #SCORE-FUNCTION = 1, then 
    ----      findMaxScoreStrat([0 : 87863] [1 : 55030] [2 : 5439045] [3 : 38165], 100, 10, 
    ----                        0 . 7 . 20 . 35 . 41 . 52 . 69 . 71 . 87 . 90) 
    ----      rewrites to 2	
    ---- 
	---- If there is only one strategy, then the encoding of that strategy is returned as the result
	eq findMaxScoreStrat([G : S], N, M, IL) =  G .
	---- Otherwise, assume the first strategy has the highest score, and then use an auxiliary operator 
	---- findMaxScoreStrat* to compute the strategy with the highest score
	eq findMaxScoreStrat([G : S] STS, N, M, IL) 
	  = findMaxScoreStrat*(STS, G, computeScore(S, N, M, IL), N, M, IL) .

	---- An auxiliary operator to findMaxScoreStrat
	op findMaxScoreStrat* : StrategySet Nat Nat Nat Nat NatList -> [Nat] .
	---- findMaxScoreStrat*(STS, G', C', N, M, IL)
    ---- 	STS: The set of strategies yet to be processed  
    ---- 	G' : The current highest-score strategy encoding  
    ---- 	C' : The score of G' (the highest score seen so far)
    ----	N  : The total size of the validator list  
    ----	M  : The length of the proposers list   
    ----	IL : The list of compromised validators    
    ----    Result: The strategy encoding of a maximum-score strategy in STS 
    ---- 
	---- If there is only one strategy G, then compute its score and compare it with the current highest G'
	---- If it's higher, return G, otherwise return G'  
	eq findMaxScoreStrat*([G : S], G', C', N, M, IL) 
		= if computeScore(S, N, M, IL) > C' then G else G' fi .
	---- If there are more than one strategy remaining, then update the current highest if necessary,
	---- and then proceed with the rest of the strategies 
	ceq findMaxScoreStrat*([G : S] STS, G', C', N, M, IL) 
		= if C > C' then 
			findMaxScoreStrat*(STS, G, C, N, M, IL)
		  else 
			findMaxScoreStrat*(STS, G', C', N, M, IL)
		  fi 
		if C := computeScore(S, N, M, IL) .



	****************************************
	**** The Rules 
	**************************************** 

	---- VHonestReveal: An honest validator revealing the seed and making a commit 
	----
	---- This rule models the behavior expected from an honest validator. The validator 
	---- consumes the doReveal message and schedules a reveal message back to the RANDAO
	---- actor object having its name, the revealed seed, and the hash of the next-round
	---- seed. In preparation for future rounds, the validator updates its state and 
	---- generates a new seed to be used later on.
	----  
  rl [VHonestReveal] : 
    limit(true, D)
 	<name: BID |		
			vapproved:	(VHL ; < VID, S, H, S', X > ; VHL') ,   
			AS' >    	
    { TG | SL }
    (VID <- doReveal(0, K))  --- 0 means honest 
    =>  ---- Update the simulation Boolean flag
    	limit(TG <= #SIM-TIME-LIMIT * D, D)
    	---- The object samples the next seed 
 		<name: BID |		
				vapproved:	(VHL ; < VID, S', H, sampleUniWithInt(#MAX-SEED-VALUE), X > ; VHL') ,   
				AS' >
		--- And schedules a reveal    	
		mytick(insert( { TG | SL }, [ TG + #TRANSMISSION-DELAY, (r <- reveal(VID, S, h(S'))) , #MSG-DROP-PROB] ))
	[print TG ": VReveal by " VID] .

	---- VCompReveal1: A compromised validator with role "isolated" possibly revealing a seed
	----
	---- This (conditional) rule models the behavior of a compromised validator with role 
	---- 'isolated' (a validator that does not belong to the compromised tail of the proposers 
	---- list. The validator consumes the doReveal message and compares the scores of
	---- revealing the seed and not revealing the seed (using computeScore). If skipping results
	---- in a strictly better score, the validator remains silent (does not schedule a reveal
	---- message) and the state remains unchanged. Otherwise, the validator schedules a reveal
	---- message back to the RANDAO actor object having its name the hash of the next-round seed. 
	---- Additionally, the validator updates its state and generates a new seed to be used later on. 
	----
	---- Recall that the score is determined by the score function the attacker is trying to
	---- optimize for (maximizing the number of the compromised validators or maximizing the
	---- the number of validators in the compromised tail).
 crl [VCompReveal1] : 
    limit(true, D)
 	<name: BID |		
			seed:			RS,  
			vapproved-size: N,
			vapproved:		(VHL ; < VID, S, H, S', X > ; VHL') ,   
			AS >
	<name: AID |
			vcomp:			(CVL ; < VID , ([ K : isolated], CRS) > ; CVL'),  
			vcomp-ilist: 	IL, 
			AS' >    
	{ TG | SL }
    (VID <- doReveal(1, K))
    =>  ---- Update the simulation Boolean flag
    	limit(TG <= #SIM-TIME-LIMIT * D, D)
		---- Check if the score of revealing is better (or the same) as that of skipping
		if B then
		---- Yes.. then reveal, and sample a new seed for the future 
 		<name: BID |		
				seed:			RS,  
				vapproved-size: N,
				vapproved:		(VHL ; < VID, S', H, sampleUniWithInt(#MAX-SEED-VALUE), X > ; VHL') ,   
				AS >
		<name: AID |
				vcomp:	(CVL ; < VID , ([ K : isolated], CRS) > ; CVL'),  
				vcomp-ilist: IL, 
				AS' >  
			mytick(insert( { TG | SL }, [ TG + #TRANSMISSION-DELAY, (r <- reveal(VID, S, h(S'))) , #MSG-DROP-PROB] ))
 		else
		---- No.. then skip, and everything remains the same 
 		<name: BID |		
				seed:	RS,  
				vapproved-size: N,
				vapproved:	(VHL ; < VID, S, H, S', X > ; VHL') ,   
				AS >
		<name: AID |
				vcomp:	(CVL ; < VID , ([ K : isolated], CRS) > ; CVL'),  
				vcomp-ilist: IL, 
				AS' >  
			mytick({ TG | SL })
	    fi
		if B := computeScore(combineSeeds(RS, S), N, #CYCLE-LENGTH, IL) 
		        >= computeScore(RS, N, #CYCLE-LENGTH, IL) 
		[print TG ": VCompReveal1 for slot " K " by " VID " => " B] .

	---- VCompReveal2: A compromised validator with role "ctailhead" possibly revealing a seed
	----
	---- This rule models the behavior of a compromised validator with role 'ctailhead' (a 
	---- compromised validator that is at the head of the compromised tail. The validator  
	---- consumes the doReveal message and then performs the following steps:
	----	1. It enumerates all possible attack strategies relevant to its position in the 
	----	   proposers list and given the current RANDAO seed and the seeds of all ctailtail 
	----       validators (createStratSet) 
	----	2. It then finds the strategy with the maximum score G' and updates the  
	----	   state to record that strategy (findMaxScoreStrat)  
	---- The validator now applies this strategy by checking B. If B is true, the validator 
	---- reveals. Otherwise, if B is false, the validator remains silent. Other updates are 
	---- similar to the above rules. 
	----
 crl [VCompReveal2] : 
    limit(true, D)
 	<name: BID |		
			seed:			RS,  
			vapproved-size: N,
			vapproved:		(VHL ; < VID, S, H, S', X >  ; VHL') ,   
			AS >    
	<name: AID |
			vcomp:			(CVL ; < VID , ([ K : ctailhead(SDL)], CRS) > ; CVL'),   
			strategy: 		G,
			vcomp-ilist: 	IL, 
			AS' >    
	{ TG | SL }
    (VID <- doReveal(1, K))
    =>  ---- Update the simulation Boolean flag
    	limit(TG <= #SIM-TIME-LIMIT * D, D)
		---- Check if the computed strategy favors revealing    	
		if B then
		---- Yes.. then reveal, and sample a new seed, and use the updated the strategy 		 
 			<name: BID |		
				seed:			RS,  
				vapproved-size: N,
				vapproved:		(VHL ; < VID, S', H, sampleUniWithInt(#MAX-SEED-VALUE), X >  ; VHL') ,   
				AS >
			<name: AID |
				vcomp:			(CVL ; < VID , ([ K : ctailhead(SDL)], CRS) > ; CVL'),  
				strategy: 		(G' quo 2),
				vcomp-ilist: 	IL, 
				AS' >  
			mytick(insert( { TG | SL }, [ TG + #TRANSMISSION-DELAY, (r <- reveal(VID, S, h(S'))) , #MSG-DROP-PROB] ))
 		else
		---- No.. then skip, and almost everything remains the same, but the updated the strategy  
 			<name: BID |		
				seed:			RS,  
				vapproved-size: N,
				vapproved:		(VHL ; < VID, S, H, S', X >  ; VHL') ,   
				AS >
			<name: AID |
				vcomp:			(CVL ; < VID , ([ K : ctailhead(SDL)], CRS) > ; CVL'),  
				strategy: 		(G' quo 2),
				vcomp-ilist: 	IL, 
				AS' >  
			mytick({ TG | SL })
	    fi
	if STS      := createStratSet(s(#CYCLE-LENGTH - K), RS, SDL)
	/\ G'       := findMaxScoreStrat(STS, N, #CYCLE-LENGTH, IL)
	/\ B 		:= (G' rem 2) == 1
	[print TG ": VCompReveal2 for slot " K " by " VID " with strategy " B " . " G'] .	
	    	
	---- VCompReveal3: A compromised validator with role "ctailtail" possibly revealing a seed
	----
	---- This rule models the behavior of a compromised validator with role 'ctailtail' (a 
	---- compromised validator that belongs to the compromised tail but is not the head of 
	---- this tail). The validator consumes the doReveal message and then checks whether 
	---- it should reveal or not according to the precomputed strategy of the attacker. If
	---- B is true, the validator reveals (schedules a reveal message
	---- as described above). Otherwise, if B is false, the validator remains silent. Other 
	---- updates to the state are similar to the above rules. 
 crl [VCompReveal3] : 
    limit(true, D)
 	<name: BID |		
			seed:			RS,  
			vapproved-size: N,
			vapproved:		(VHL ; < VID, S, H, S', X >  ; VHL') ,   
			AS >    
	<name: AID |
			vcomp:			(CVL ; < VID , ([ K : ctailtail], CRS) > ; CVL'),   
			strategy: 		G,
			vcomp-ilist: 	IL, 
			AS' >    
	{ TG | SL }
    (VID <- doReveal(1, K))
    =>  ---- Update the simulation Boolean flag
    	limit(TG <= #SIM-TIME-LIMIT * D, D)
		---- Check if the computed strategy favors revealing    	
		if B then 
 		---- Yes.. then reveal, and sample a new seed, and use the updated the strategy 		 
 			<name: BID |		
				seed:			RS,  
				vapproved-size: N,
				vapproved:		(VHL ; < VID, S', H, sampleUniWithInt(#MAX-SEED-VALUE), X >  ; VHL') ,   
				AS >
			<name: AID |
				vcomp:			(CVL ; < VID , ([ K : ctailtail], CRS) > ; CVL'),  
				strategy: 		(G quo 2),
				vcomp-ilist: 	IL, 
				AS' >  
			mytick(insert( { TG | SL }, [ TG + #TRANSMISSION-DELAY, (r <- reveal(VID, S, h(S'))) , #MSG-DROP-PROB] ))
 		else
 		---- No.. then skip, and almost everything remains the same, but the updated the strategy  
 			<name: BID |		
				seed:			RS,  
				vapproved-size: N,
				vapproved:		(VHL ; < VID, S, H, S', X >  ; VHL') ,   
				AS >
			<name: AID |
				vcomp:			(CVL ; < VID , ([ K : ctailtail], CRS) > ; CVL'),  
				strategy: 		(G quo 2),
				vcomp-ilist: 	IL, 
				AS' >  
			mytick({ TG | SL })
	    fi
	    if B := (G rem 2) == 1
		[print TG ": VCompReveal3 for slot " K " by " VID " => " B] .	    	


	---- VArrive: A new validator requesting to join the system 
	----
	---- This rule models the arrival of a fresh validator into the system. 
	---- Upon receiving the 'spawn' message, the validator generator creates
	---- new validator records and adds them to the pending list of validators,
	---- and the size of pending validators is incremented. If the validator is 
	---- compromised (controlled by the attacker), the list of (compromised) 
	---- validator records is also augmented, and the list of compromised 
	---- validator indices and its size are updated accordingly. In any case, 
	---- The generator updates its state by preparing the index, seed and the
	---- compromised state of the next fresh validator to be generated, and
	---- schedules another 'spawn' message delayed by the validator arrival
	---- delay.
	----  
  rl [VArrive] : 
    limit(true, D)
	<name: BID |												
		vpending:       VHL, 
		vpending-size:  M,
		AS >
    <name: AID  | 
		vcomp-ilist: IL, 
    	vcomp-size: M', 
    	AS' >  								
    <name: VGID |
	    	vcount: N, 
	    	contract: RID,
	    	next-seed: S,
		   	next-comp: B,
	    	AS'' >
    { TG | SL }
    (g <- spawn)
    =>  ---- Update the simulation Boolean flag
    	limit(TG <= #SIM-TIME-LIMIT * D, D)
    	---- Add a new record to the pending list and increment the pending list counter 
		<name: BID |												
			vpending:       (VHL ; < v(N), S, h(S), sampleUniWithInt(#MAX-SEED-VALUE), (- #DEPOSIT-SIZE) >), 
			vpending-size:  s(M),
			AS >
		---- Check if the validator is compromised 
		if B then
			--- Yes.. then add its index to the compromised list and increment the counter 
	    	<name: AID  | 
				vcomp-ilist: (IL . N), 
	    		vcomp-size: s(M'), 
	    		AS' >  								
	    else
			--- No.. then do nothing here  
	    	<name: AID  | 
				vcomp-ilist: IL, 
	    		vcomp-size: M', 
	    		AS' >  			
	    fi 	
		---- The generator prepares for the next validator to arrive  	    				
    	<name: VGID |
		    	vcount: s(N), 
		    	contract: RID,
		    	next-seed: sampleUniWithInt(#MAX-SEED-VALUE),
		    	next-comp: sampleBerWithP(#ATTACK-PROB),
	    		AS'' >
		mytick(insert( { TG | SL }, 
			[ TG + #VARRIVAL-DELAY, (VGID <- spawn) , 0]))
	[print TG ": VArrive: s(" N ")"] .
endm

mod INIT-STATE is
	protecting VALIDATOR-BEHAVIOR .
	protecting RANDAO-BEHAVIOR .

	vars I J M N K : Nat .
	vars S S' : Seed .
	vars RID VID AID : ActorName .
	vars VHL VHL' : VRecordList .
	vars CVL CVL' : CVRecordList .
	vars AS AS' AS'' : AttributeSet .
	vars VC : Config .
	vars B : Bool .
	var X : Int .
	vars IL IL' IL1 IL1' : NatList .
	vars RO : Role .
	vars CRS : CRoleSet .
	var P : Float .

	---- Sampling an initial list of compromised validator indices 
	op sampleInitCompromised : Nat Float NatList -> [NatList] .
	---- sampleInitCompromised(N, P, IL)
	----   N  : The size of the validator list 
	----   P  : The attack probability (#ATTACK-PROB)
	----   IL : The compromised list sampled so far 
	----   Result: A list of compromised indices sampled from N with probability P 
	----
	---- If N is zero, no more sampling and return the sampled list IL
	eq sampleInitCompromised(0, P, IL) = IL .
	---- If N is positive, do a Bernoulli trial with bias P
	---- If successful, add N to IL. Otherwise move on to the next trial. 
	rl sampleInitCompromised(s(N), P, IL) => 
		if sampleBerWithP(P) then 
			sampleInitCompromised(N, P, N . IL) 
		else 
			sampleInitCompromised(N, P, IL) 
		fi . 

	---- Generating a list of preliminary validator records 
	op makeVL : Nat -> [VRecordList] .
	---- makeVL(N)
	----    N : The size of the list to be generated 
	----    Result: A list of size N of partially populated validator records 
	----            (records will be missing appropriate hash values)
	---- 
	eq makeVL(0) = nilVHL .
	eq makeVL(s(N)) 
	  = makeVL(N) ; 
		< v(N), sampleUniWithInt(#MAX-SEED-VALUE), h(0), 
		  sampleUniWithInt(#MAX-SEED-VALUE) , (- #DEPOSIT-SIZE) > .

	---- Creating the initial list of scheduled doReveal messages 
	op createInitDoReveals : NatList Nat NatList -> [ScheduleList] .
	---- createInitDoReveals(IL, N)
    ----    IL: list of validator indices (target validators)
    ----    N : a counter representing the number of messages created so far 
    ----    IL': list of compromised validator indices
    ----    Result: A list of scheduled doReveal messages targeted at validators  
    ---- 			in IL
	---- 
	eq createInitDoReveals(nilIL, N, IL') 
		= nil .
	eq createInitDoReveals(IL . I, s(N), (IL1 . I . IL1')) 
		= createInitDoReveals(IL, N, (IL1 . I . IL1')) ; [0.01 + float(N), (v(I) <- doReveal(1, s(N))) , #MSG-DROP-PROB] .
	eq createInitDoReveals(IL . I, s(N), IL') 
		= createInitDoReveals(IL, N, IL') ; [0.01 + float(N), (v(I) <- doReveal(0, s(N))) , #MSG-DROP-PROB] [owise] .


	---- initBlockchain(N): Initialize the Blockchain object with N validator records
	op initBlockchain : Nat -> [Object] .
	eq initBlockchain(N) = 
		<name: bc |												---- The Blockchain Object
			seed:           sampleUniWithInt(#MAX-SEED-VALUE),  ---- seed of previous game round
			vpending:       nilVHL,             				---- list of pending validators 
			vpending-size:  0,                  				---- their count
			vapproved:      makeVL(N),     						---- list of approved validators (as general validator records) 
			vapproved-size: N           						---- their count
		> .

	---- initAttacker(N): Initialize the Attacker object with N validator records
	op initAttacker : Nat -> [Object] .
	eq initAttacker(N) = 
		<name: a |												---- The Attacker Object
			vcomp:			nilCVL,       						---- Private validator records
			vcomp-ilist:	sampleInitCompromised(N, #ATTACK-PROB, nilIL),	---- list of compromised validator indices
			vcomp-size:		0,           						---- their count
			strategy:		0									---- the attacker's strategy 
		> .	

	---- initRandao(M, N, K): Initialize the RANDAO object with N validator records,
	---- M proposers and a deposit-per-validator given by K 
	op initRandao : Nat Nat Nat -> [Object] .
	eq initRandao(M, N, K) =
		<name: r |								---- The RANDAO Contract
			status:         ready,              ---- status can be 'ready' or 'processing'
			balance:        (N * K),       		---- current contract balance 
			success-rounds: 0,                  ---- number of successful rounds
			precords:  		nilPL, 				---- proposer records for participants in the current game round
			prop-size:      M,                  ---- their count 
			prop-ilist: 	nilIL, 				---- their indices,       
			pnext:          1                   ---- next validator (time slot) to process
		> .

	---- initVGen(N, A): Initialize the validator generator object with N 
	---- as the next index, and A as the RANDAO object name 
	op initVGen : Nat ActorName -> [Object] .
	eq initVGen(N, RID) = 
		<name: g | 
			vcount: 	N, 
			contract: 	RID,
			next-seed: 	sampleUniWithInt(#MAX-SEED-VALUE),
			next-comp: 	sampleBerWithP(#ATTACK-PROB) > .

	---- initState: Generate the initial state of the protocol
	rl initState =>
		initSystem(
			initProposers(
				initBlockchain(#INIT-VLIST-SIZE)
				initAttacker(#INIT-VLIST-SIZE)
				initRandao(#CYCLE-LENGTH, #INIT-VLIST-SIZE, #DEPOSIT-SIZE)
				, #INIT-VLIST-SIZE, #CYCLE-LENGTH
		), #INIT-VLIST-SIZE
	) .

	---- initProposers(C, N, M): A helper function to initialize (in two steps)  
	---- the proposers list in the configuration C, given N as the total number  
	---- of validators in the system and M as the number of proposers

	---- The first step is to generate the list of proposer indices
	op initProposers : Config Nat Nat -> [Config] .
	eq initProposers(
		<name: bc | seed: S, AS >
		<name: r  |	prop-ilist: nilIL, AS' >        
		VC, N, M) 
		= initProposers(
			<name: bc | seed: S, AS >  
			<name: r  | prop-ilist: sampleIndexList(N, M, S), AS' >        
			VC, N, M) .

	---- The second step is form the list of proposer records 
	eq initProposers(
		<name: bc | vapproved: VHL, AS >  
		<name: r  |	prop-ilist: (I . IL), precords: nilPL, AS' >        
		<name: a  | vcomp: nilCVL, vcomp-ilist: IL', vcomp-size: 0, AS'' > 								
		VC, N, M) 
		= <name: bc | vapproved: VHL, AS >  
		  <name: r  | prop-ilist: (I . IL), precords: makePropRecords(I . IL), AS' >        
		  <name: a  | vcomp: setNewCVRoles(makeCVL((I . IL), IL'), (I . IL), VHL), vcomp-ilist: IL', vcomp-size: length(IL'), AS'' > 								
		  VC .

	---- initSystem(C, I): A helper function to initialize all validator records and the 
	---- configuration as a whole. The function walks through the set of validators records 
	---- one-by-one setting their hash values. 
	op initSystem : Config Nat -> [Config] .
	eq initSystem(
			<name: bc    | vapproved: (VHL ; < v(I), S, h(0), S', X >   ; VHL'), AS > 	
			VC, s(I))
		= initSystem(
				<name: bc    | vapproved: (VHL ; < v(I), S, h(S), S', X >   ; VHL'), AS > 	
				VC, I) .
	---- Once done with all validators, return the updated configuration augmented with
	---- the other configuration components (limit, round, validator generator, ... )
	eq initSystem(
			<name: r | prop-ilist: IL, prop-size: M, AS > 
			<name: a | vcomp-ilist: IL', AS' >  
			VC, 0) 
		= limit(false, 0.0)
		  <name: r | prop-ilist: IL, prop-size: M, AS > 
		  <name: a | vcomp-ilist: IL', AS' >  
		  VC 
		  if #DYNAMIC-VLIST? then
			initVGen(#INIT-VLIST-SIZE, r)
			mytick(insertList({ 0.0 | createInitDoReveals(IL, M, IL') }, [1.0, r <- nextSlot(2), #MSG-DROP-PROB] ; [#VARRIVAL-DELAY, g <- spawn, 0] )) 		  	
		  else
			mytick(insert({ 0.0 | createInitDoReveals(IL, M, IL') }, [1.0, r <- nextSlot(2), #MSG-DROP-PROB])) 
		  fi .
endm


mod ANALYSIS-INTERFACE is
	protecting INIT-STATE .

    vars C : Config .
    vars B : Bool .
    vars D : Float .
    vars AID RID : ActorName .
    vars CVL : CVRecordList .
    vars AS AS' : AttributeSet .
	vars IL IL' IL1 IL1' : NatList .

    *******************************************************************
    ***** 0. matchScore: the number of compromised proposers in the 
    *****    proposers list
    *******************************************************************
    op matchScore : Config -> Float .
    eq matchScore(
		<name: AID | vcomp-ilist: IL, AS >  
		<name: RID | prop-ilist: IL', AS' >  
		C )
      = float(countCompromised(IL', IL)) .

    *******************************************************************
    ***** 1. lastWordScore: the length of the compromised tail (last 
    *****    revealers) of the proposers list
    *******************************************************************
	op lastWordScore : Config -> Float .
    eq lastWordScore(
		<name: AID | vcomp-ilist: IL, AS >  
		<name: RID | prop-ilist: IL', AS' >  
		C )
      = float(countCompromisedTail(IL', IL)) .


	***** to be used by PVeStA

	---- D is the game round number 
	---- B is a flag indicating whether the *macro tick* (or game round in this case) is ongoing
	---- tick is PVeStA's step 
    eq tick(limit(B, D) C) =  limit(true, D + 1.0) C .

    ---- matchScore
    eq val(0, C) = matchScore(C) .
 	---- lastWordScore
    eq val(1, C) = lastWordScore(C) .
endm










        
