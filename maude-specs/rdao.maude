***(
*** Part of rdao-smc: A probabilistic rewriting model of RANDAO schemes
*** 
*** Musab A. Alturki
*** September 2018
*** Runtime Verifcation Inc. 
)

--- import the global paramters defined in rdao-params.maude
load rdao-params.maude

***( 
*** Hash Module
***
*** This modules defines a very high-level abstraction of hashes and 
*** and hash operations. We note that this level of abstraction is 
*** enough for our purposes as we do not deal with the internals of
*** hashing, and simply assume that cryptographically secure hash 
*** functions are used.
***
)
mod HASH is
	protecting PARAMS .
	protecting NAT .

	---- Seeds are represented by naturals
	sort Seed .
	subsort Nat < Seed .

	vars S S' : Seed .

	---- Combining (XOR'ing) seeds to get a new one 
	---- #MAX-SEED-VALUE is taken to be the maximum value that can be 
	---- generated by the random funciton of Maude (This upper bound is 
	---- not really necessary but is there for efficiency)
	op combineSeeds : Seed Seed -> [Seed] .
	eq combineSeeds(S, S') = (S xor S') rem #MAX-SEED-VALUE .


	---- Hash datatype
	sort Hash .
	---- A hash is a seed wrapped by the hash operator (a constructor)
	---- e.g. if S is a seed, its hash is given by h(S)
	op h : Seed -> Hash [ctor frozen] .

	---- Relevant operations and properties of hashing

	---- The Commit operation
	---- Committing on a seed returns the hash of that seed 
	op commit : Seed -> Hash .
	eq commit(S) = h(S) .

	---- The Reveal operation
	---- Revealing on a hash of a seed exposes that seed 
	op reveal : Hash -> Seed .
	eq reveal(h(S)) = S .

endm


***( 
*** Nat Lists
***
*** This modules defines a list of natural numnbers using an associative
*** dot operator. Lists of naturals are heavily used by the model to 
*** represent lists of validator object identifiers (identifiers of
*** validator objects will be defined as wrapped natural numbers).
***  
*** e.g. 4 . 0 . 2 . 4 . 10 is a valid list of naturals
***
)
mod NATLIST is
	extending HASH .
	protecting SAMPLER .

	---- The list of naturals datatype
	sort NatList .
	---- A natural number is a (degenarate) list of naturals
	subsort Nat < NatList .

	---- List constructors
	op nilIL : -> NatList [ctor] .
	op _._ : NatList NatList -> NatList [ctor assoc id: nilIL] .

	---- Operations on lists:
	vars I M N K : Nat .
	vars S : Seed . 
	vars IL IL' IL1 IL2 IL1' IL2' : NatList .

	---- computeNewNatList(N, M, S): 
	---- 	N: the (current) total number of approved validators in the system 
	----    M: the CYCLE-LENGTH (the number of proposers in the proposer list)
	----    S: the (starting) seed to be used in computing the list of numbers 
	----    Result: Returns a list of indices (natural numbers) computed using  
	----            the sequence of seeds S, S+1, ... , S+(M-1)
	----    Note: In an actual implementation of the system, the seed S is used 
	----          along with a pseudo-random number generator to sample the 
	----          list of indicies. This is not done here, as it would result 
	----          in a specification that is very inefficiently executable. 
	----          The inefficicncy is due to Maude's implementation of the 
	----          random function being based on the Mersenne Twister RNG (in
	----          which computing the random value corresponding to S requires
	----          computing the previous value for S-1). In other words, Maude's 
	----          random function was not designed to support user-supplied
	----          seeds. To resolve this issue, we generate our pseudo-random
	----          number using an arithmetic combination of the seed S and the
	----          position in the list for which the number is being generated. 
	----          We note that this approach is still faithful to the original 
	----          protocol since the seed S itself is generated pseduo-randomly
	----          (using the function random), and thus, the resulting number 
	----          is also pseudo-random. 
	----    e.g.: computeNewNatList(100, 5, 748692346) = 80 . 20 . 52 . 76 . 92
	----
    op computeNewNatList : Nat Nat Seed -> [NatList] .
    eq computeNewNatList(N, 0, S) = nilIL .
    ----eq computeNewNatList(N, s(K), S) = random(S + s(K)) rem N . computeNewNatList(N, K, S) .
	eq computeNewNatList(N, s(K), S) = (S * s(K) * s(s(K))) rem N . computeNewNatList(N, K, S) .

    ---- countCompromized(IL1, IL2): 
    ----    IL1: A list of indicies (the proposers list)
    ----    IL2: A list of indicies (the compromized validator list)
    ----    Result: Returns the number of indices in the first list that appear 
    ----            in the second (and hence the number of compromized validators
    ----            in the proposers list)
    ----    e.g.: countCompromized(2 . 5 . 3 . 2 . 9 . 4, 1 . 2 . 4 . 5 . 9) = 5
    ----    e.g.: countCompromized(2 . 5 . 3 . 2 . 9 . 3, 1 . 2 . 4 . 5 . 9) = 4
    ---- 
	op countCompromized : NatList NatList -> [Nat] .
	eq countCompromized(IL1, IL2) = countCompromized*(IL1, IL2, 0) .

	---- A helper (tail-recursive) function to countCompromized
	op countCompromized* : NatList NatList Nat -> [Nat] .
	eq countCompromized*((IL1 . I . IL1'), (IL2 . I . IL2'), N) = countCompromized*((IL1 . IL1'), (IL2 . I . IL2'), s(N)) .
	eq countCompromized*(IL1, IL2, N) = N [owise] .

    ---- countCompromizedTail(IL1, IL2): 
    ----    IL1: A list of indicies (the proposers list)
    ----    IL2: A list of indicies (the compromized validator list)
    ----    Result: Returns the size of the longest (continuous) tail of indices  
    ----            in the first list that appears in the second (and hence the 
    ----            number of last validators that are compromized in the 
    ----            proposers list)
    ----    e.g.: countCompromizedTail(2 . 5 . 3 . 2 . 9 . 4, 1 . 2 . 4 . 5 . 9) = 3
    ----    e.g.: countCompromizedTail(2 . 5 . 3 . 2 . 9 . 3, 1 . 2 . 4 . 5 . 9) = 0
    ----
	op countCompromizedTail : NatList NatList -> [Nat] .
	eq countCompromizedTail(IL1, IL2) = countCompromizedTail*(IL1, IL2, 0) .

	---- A helper (tail-recursive) function to countCompromizedTail
	op countCompromizedTail* : NatList NatList Nat -> [Nat] .
	eq countCompromizedTail*((IL1 . I), (IL2 . I . IL2'), N) = countCompromizedTail*(IL1, (IL2 . I . IL2'), s(N)) .
	eq countCompromizedTail*(IL1, IL2, N) = N [owise] .

	---- computeScoreFunction(I, IL, IL'):
	----    I:  The index of the score function to be used 
	----        0 for countCompromized
	----        1 for countCompromizedTail
	----    IL: The first list 
	----    IL: The second list 
	----    Result: Computes the score of IL and IL' based on the function index I 
    ----    e.g.: computeScoreFunction(0, 2 . 5 . 3 . 2 . 9 . 4, 1 . 2 . 4 . 5 . 9) = 5
    ----    e.g.: computeScoreFunction(1, 2 . 5 . 3 . 2 . 9 . 4, 1 . 2 . 4 . 5 . 9) = 3
    ----
	op computeScoreFunction : Nat NatList NatList -> [Nat] .
	eq computeScoreFunction(0, IL, IL') = countCompromized(IL, IL') .
	eq computeScoreFunction(1, IL, IL') = countCompromizedTail(IL, IL') .

endm


***( 
*** Validator Roles
***
*** This modules defines data structures specifying validator roles.
*** A validator role defines the behavior of a validator as a member
*** of the proposers list. A validator may be honest, in which case 
*** it behaves according to the protocol. A compromized validator may
*** assume one of three roles labeled: isolated, ctailhead and 
*** ctailtail, depending on its position in the proposers list. An 
*** isolated validator is one that does not belong to a compromized 
*** tail of the list. ctailhead and ctailtail are the validator roles 
*** for the head and the tail of the compromized tail. We give an
*** example below:
***  
*** Example 1: Assuming 3, 5, 7 and 9 are the only compromized 
***            validators, in the list of proposers 
***                       1 . 2 . 3 . 5 . 4 . 7 . 9
***            we have the following roles:
***            * 1, 2 and 4 are honest
***            * 3 and 5 are isolated
***            * 7 is a ctailhead
***            * 9 is a ctailtail
***
*** Since a validator with role ctailhead will need the seeds of all
*** vaildators in the rest of the tail of the list (ctailtail validators),
*** the ctailhead role maintains this list of seeds as an argument (this
*** is another design for efficincy that is not strictly needed).
***
*** Finally, since the same validator may appear more than once in the 
*** proposers list, a validator may have more than one role. We therefore
*** index a role by the slot number for that role. For instance, in the 
*** example above, if the list was 1 . 2 . 7 . 5 . 4 . 7 . 9, validator 7
*** would have two roles (a role set): [3 : isolated] [6 : ctailhead].
)
mod ROLES is 
	protecting NATLIST .

	---- Honest validator role 
	sort Honest .
	---- Honest constructor 
	op honest : -> Honest [ctor] .

	---- Compromized validator role positions: 
	---- constructers for isolated, ctailhead(IL) and ctailtail
	sort CPosition .
	ops isolated ctailtail : -> CPosition [ctor] .
	op  ctailhead : NatList -> CPosition [ctor] .

	---- Roles and Role Sets
	sort Role CRoleSet CRole .
	---- A 'Role' is either 'Honest' or a set of slot-indexed compromized
	---- roles 'CRoleSet'
	subsort Honest CRoleSet < Role .
	---- A single 'CRole' is a (degenerate) instance of 'CRoleSet'
	subsort CRole < CRoleSet .

	---- A compromized role is a slot-indexed compromized role position 
	op [_:_] : Nat CPosition -> CRole [ctor].
	---- A set of compromized roles is constructed by mtCRS, for the empty
	---- set, and the associative commutative comma operator with id mtCRS
	op mtCRS : -> CRoleSet [ctor] .
	op _,_ : CRoleSet CRoleSet -> CRoleSet [ctor comm assoc id: mtCRS] .
endm


***( 
*** Validator Records
***
*** This modules defines validator records, which are data structures used 
*** to maintain details of validators needed for the proper execution of the 
*** protocol and the attacker. The distinction below between public and 
*** private records is not really significant; It's, in fact, an unfortunate  
*** artifact of the how the specification evoloved, and could (should) be 
*** eliminated in the future. What's important is that a record maintains:
***		* The validator's (actor object) name
***     * The hash of the current seed 
***     * The validator's profit (in Ether) 
***		* The current-round seed
***     * The next-round seed 
***     * The validator's role
***
)
mod VRECORD is
	protecting APMAUDE .
	protecting NATLIST .
	protecting ROLES .

	---- Public validator record
	sort VRecord .
	---- A public validator record is a triple < A, H, N >, with A the 
	---- validator's name (identifier), H its hash, and N its net balance.
	op <_,_,_> : ActorName Hash Int -> VRecord [ctor] .

	---- Public validator record list 
	sort VRecordList .
	---- A public validator record list is constructed by a single record,
	---- the empty record list nilVHL, or by the associative semi-colon
	---- operator on record lists, with nilVHL the identity element.
	subsort VRecord < VRecordList .
	op nilVHL : -> VRecordList [ctor] .
	op _;_ : VRecordList VRecordList -> VRecordList [ctor assoc id: nilVHL] .

	---- Private validator record
	sort CVRecord .
	---- A private validator record is a quadruple < A, S, S', R >, with A the 
	---- validator's name (identifier), S and S' are its current and next-round
	---- seeds respectively, and R its role.
	op <_,_,_,_> : ActorName Seed Seed Role -> CVRecord [ctor] .

	---- Private validator record list 
	sort CVRecordList .
	---- A private validator record list is constructed by a single record,
	---- the empty record list nilCVL, or by the associative semi-colon
	---- operator on record lists, with nilCVL the identity element.
	subsort CVRecord < CVRecordList .
	op nilCVL : -> CVRecordList [ctor] .
	op _;_ : CVRecordList CVRecordList -> CVRecordList [ctor assoc id: nilCVL] .
endm

***( 
*** Proposer Records
***
*** This modules defines proposer records maintained by the RANDAO object.
*** These are simple data structures used to record whether a proposer 
*** manageed to successfully propose a valid block and reveal its seed. 
*** A proposer record is a pair [A, B], with A the proposers name, and B
*** a boolean flag indicating whether A successfully revealed its seed. 
***
)
mod PROPOSERS is
	protecting APMAUDE .

	---- Proposer record 
	sort Proposer .
	op [_,_] : ActorName Bool -> Proposer [ctor] .
	---- Proposer record list 
	sort ProposerList .
	subsort Proposer < ProposerList .
	op nilPL : -> ProposerList [ctor] .
	op _;_ : ProposerList ProposerList -> ProposerList [ctor assoc id: nilPL] .
endm

***(
*** Attack strategies
***  
*** This module defines data structures and operations for specifying
*** attack strategies for compromized validators appearing in the proposers
*** list's compromized tail (the ones with roles ctailhead and ctailtail). 
*** An attack strategy is a list of skip instructions (Boolean values) 
*** instructing validators in the compromized tail to either reveal or skip
*** their turns in the round. A strategy also comes with a score, which the 
*** attacker can compute to decide the best attack strategy given the 
*** current circumstances. The score is a measure of the success of the 
*** attack (the number of validators the attack can control in the next
*** round, for example). For instance, the strategy [2 : true . false]
***	specifies that the next validator should reveal its seed while the one 
*** after it should remain silent, and that this strategy has a score of 2.  					
*** 
)
mod STRATEGY is
	protecting NAT .

	---- Skip list 
	sort SkipList .
	---- true means reveal, false means refrain 
	subsort Bool < SkipList .
	---- A skip list can be empty (nilSKL), or the associative dot 
	---- juxtaposition of other skip lists with id nilSKL.
	op nilSKL : -> SkipList [ctor] .
	op _._ : SkipList SkipList -> SkipList [ctor assoc id: nilSKL] .

	---- Attack strategy 
	sort Strategy .
	---- A strategy is a pair [I : SKL], with SKL is a skip list and I its
	---- score.
	op [_:_] : Nat SkipList -> Strategy [ctor] .

	---- Attack strategy list 
	sort StrategyList .
	---- A strategy list is constructed by a single strategy, the empty
	---- strategy list nilSTL, or by the associative empty juxtaposition
	---- operator on strategy lists, with nilSTL the identity element.
	subsort Strategy < StrategyList .
	op nilSTL : -> StrategyList [ctor] .
	op __ : StrategyList StrategyList -> StrategyList [ctor assoc id: nilSTL] .

	---- Defined operations 
	vars N I : Nat . 
	vars SKL : SkipList .
	vars STL : StrategyList .

	---- enumStrategies(N):
	----    N: a natural number 
	----    Result: a list of all possible strategies of length NatList
	----            with all their scores initialized to 0.
	----    e.g.: enumStrategies(2) = 
	----                  [0 : false . false] 
	----                  [0 : false . true] 
	----                  [0 : true . false] 
	----                  [0 : true . true]
	----
	op enumStrategies : Nat -> [StrategyList] .
	eq enumStrategies(0) = [0 : nilSKL] .
	eq enumStrategies(s(N)) = augment(enumStrategies(N)) .
	---- A helper fucntion to enumStrategies(N)
	op augment : StrategyList -> [StrategyList] .
	eq augment(nilSTL) = nilSTL .
	eq augment([I : SKL] STL) = [I : SKL . false] [I : SKL . true] augment(STL) .
endm

***(
*** Actor Names
***  
*** This module defines the actor names of the actor objects that could 
*** appear in a configuration. There are five actors in total:
***   v(I) : a validator with index I 
***   bc   : the blockchain actor (modeling the state of the protocol)
***   r    : the RANDAO contract actor 
***   a    : the attacker actor 
***   vg   : the validator generator actor (for modeling a dynamic validator set)
*** 
*** We note that, for execution efficincy, a validator actor v(I) is not  
*** represented by its own actor object, but rather by its validator records
*** stored in other objects (bc and a).  					
)
mod OBJECTS is 
	extending APMAUDE .
    op v  : Nat -> ActorName .   --- Validators
    op bc :     -> ActorName .   --- Blockchain 
    op r  :     -> ActorName .   --- RANDAO Contract
    op a  :     -> ActorName .   --- Attacker
    op vg :     -> ActorName .   --- Validator Generator
endm

***(
*** Actor attributes
***  
*** This module defines all attributes that may be part of an actor object
*** in the specification. An attribute is a key-value pair that records
*** important information about the state of an actor. Note that an 
*** attribute may appear in more than one actor type.
***   	
*** Below, we list the attributes of each actor object:
***
*** Blockchain:
***		<name: bc |					---- The Blockchain Object
***			seed:           S,  	---- seed of previous game round
***			vpending:       VHL,    ---- list of records of pending validators 
***			vpending-size:  N,      ---- their count
***			vappr:          VHL',   ---- list of records of approved validators  
***			vappr-size:     N'      ---- their count
***		> .
***
*** RANDAO Contract:
***		<name: r |					---- the RANDAO Contract
***			status:         U,      ---- status can be 'ready' or 'processing' 
***			balance:        N,      ---- current contract balance 
***			success-rounds: J,      ---- number of successful rounds
***			proposers:      PL, 	---- proposers participating in the current game round
***			prop-size:      M,      ---- their count (in the steady state, this must be equal to #CYCLE-LENGTH)
***			prop-ilist: 	IL, 	---- their indices,       
***			pnext:          I       ---- next validator (time slot) to process
***		> .
***
*** Attacker:
*** 	<name: a |					---- the Attacker Object
***			vcomp:			CVL,	---- private validator records
***			vcomp-ilist:	IL,		---- a list of the compromized validator indices
***			vcomp-size:		N,      ---- the size of IL
***			strategy:		ST		---- the attacker's strategy (for tails controlled by the attacker)
***		> .	
***
***	Validator Generator: 
***		<name: vg | 				---- the validator generator 
***			vcount: N, 				---- the index of the next validator to be generated 
***			contract: RID,			---- the name of the RANDAO contract 
***			next-seed: S,			---- the seed of the next validator to be generated
***			next-comp: B > .		---- a Boolean indicating whether the next validator is compromized or not 
***
)
mod ATTRIBUTES is
    protecting VRECORD .
    protecting PROPOSERS .
    protecting NATLIST .
    protecting STRATEGY .

    --- states of an actor
    sort Status .
    ops processing ready : -> Status . 

    --- Attributes (as explained above)
    op status:_         : Status		-> Attribute [format (m o d)] .  
    op balance:_        : Nat			-> Attribute [format (m o d)] .  
    op seed:_           : Seed			-> Attribute [format (m o d)] .
    op vappr:_          : VRecordList 	-> Attribute [format (m o d)] .
    op vappr-size:_     : Nat			-> Attribute [format (m o d)] .
    op vpending:_       : VRecordList	-> Attribute [format (m o d)] .
    op vpending-size:_  : Nat			-> Attribute [format (m o d)] .
    op proposers:_      : ProposerList	-> Attribute [format (m o d)] .
    op prop-ilist:_     : NatList		-> Attribute [format (m o d)] .
    op prop-size:_      : Nat			-> Attribute [format (m o d)] .
    op pnext:_          : Nat 			-> Attribute [format (m o d)] .
    op success-rounds:_ : Nat			-> Attribute [format (m o d)] .
    op contract:_       : ActorName 	-> Attribute [format (m o d)] .
    op next-seed:_      : Seed 			-> Attribute [format (m o d)] .
    op vcomp:_ 			: CVRecordList	-> Attribute [format (m o d)] .
    op vcomp-ilist:_ 	: NatList 		-> Attribute [format (m o d)] .
    op vcomp-size:_     : Nat			-> Attribute [format (m o d)] .
    op strategy:_ 		: Strategy 		-> Attribute [format (m o d)] .
    op vcount:_ 		: Nat 			-> Attribute [format (m o d)] .
    op next-comp:_ 		: Bool 			-> Attribute [format (m o d)] .
endm


***(
*** Message Content
***
*** This module defines message contents (payload) that could potentially be 
*** used in messages exchanged between actors of the system. Recall that a
*** message has the form (A <- C), where A is the target actor and C is the 
*** content of the message, which we define here. 
***    
)
---- Message contents
mod MESSAGES is
    protecting VRECORD .
    protecting PROPOSERS .
   	extending APMAUDE .

	---- Message Contents:

	---- reveal(A, S, H): A reveal by actor A of the seed S while  
	---- committing to the next seed using H 
	op  reveal 		: ActorName Seed Hash 	-> Content .

	---- nextSlot(K): schedule advancing the process to the next slot
	---- (used in self-addressed messages) 
	op  nextSlot 	: Nat  					-> Content . 

	---- nextRound(): schedule advancing the process to the next round 
	---- (used in self-addressed messages) 
	op  nextRound 	:   					-> Content . 
 
	---- doReveal(K): schedule a possible reveal action at slot K 
	---- (used in self-addressed messages) 
	op  doReveal	: Nat					-> Content . 

	--- doReveal*() : schedule the second step of the reveal action 
	---- (used in self-addressed messages) 
	op  doReveal*	:				 		-> Content . 

	--- spawn() : schedule arrival of the next validator to the system 
	---- (used in self-addressed messages when dynamic validators are 
	---- assumed) 
	op  spawn		:						-> Content . 
endm

***(
*** Actor Configuraiton
***
*** This module defines additional configuration components (in addition
*** to actors, messages and the scheduler which were defined in a previous
*** module).  
***    
)
---- 
mod CONFIG is
	protecting ATTRIBUTES .
	protecting OBJECTS .
	protecting MESSAGES .
	protecting NATLIST .

    --- Additional configuration fields

    ---- limit(B, F): A control device that allows us to specify the length
    ---- of a simulation run (the macro step captured by 'tick')
    op limit : Bool Float   -> Config [format (nb! o)] .

    ---- round(F): Maintains the current RANDAO game round 
    ---- (not strictly needed but is there for convenience)
    op round : Float   -> Config [format (nb! o)] .
endm


***(
*** RANDAO Actions
***
*** This module defines how the RANDAO actor behaves. Behavior is 
*** captured by rewrite rules specifying transitions in the system.
*** There are three transitions:
*** 1. RAdvanceSlot: which advances the process to the next slot
*** 2. RAdvanceRound: which advances the process to the next round
*** 3. RProcessReveal: which processes a reveal message from a proposer
***    
*** The module also defines other operations needed for the 
*** specification of these transitions.
***
)
mod RANDAO-BEHAVIOR is
	protecting CONFIG .
	protecting PARAMS .

	vars S S' RS 					: Seed .
	vars AS AS' AS'' 				: AttributeSet . 
	vars T TG TS TS' TR TR' D R F 	: Float .
	vars SL SL' 					: ScheduleList . 
	vars ST ST' 					: Strategy .
	vars SSTL STL STL' 				: StrategyList .
	vars CID VID RID OID AID BID 	: ActorName .
  	vars H H' 						: Hash .
	vars I J K L M N N' 			: Nat .
	vars VHL VHL' : VRecordList .
	vars CVL CVL' : CVRecordList .
	vars CL : ProposerList .
	vars C : Content .
	vars B B' T? : Bool .
	vars IL : NatList .
	vars X : Int .
	vars RO : Role .
	vars SKL SKL' : SkipList .
	vars CRS : CRoleSet . 
	vars SDL : NatList .

	****************************************
	**** Some Operations Needed by the Rules
	**************************************** 

	---- updateRewards(VHL, CL) 
	----    VHL: list of validator records 
	----    CL: list of proposer records 
	----    Result: The validator records list VHL where each successful reveal 
	----            is rewarded by increasing the corresponding validator balance.
	----            Whether a reveal was successful is given by the appropriate 
	----            record in CL.
	---- Note 1: Rewarding means adding 2 Ether to the validator record balance
	---- Note 2: This is so far unused (but could be built on in a future version)
	----
	---- e.g. updateRewards(< v(0) , H , 10 >, [v(0) , true])  = < v(0) , H , 12 >
	---- e.g. updateRewards(< v(0) , H , 10 >, [v(0) , false]) = < v(0) , H , 10 >
	----
    op updateRewards : VRecordList ProposerList -> [VRecordList] .
    eq updateRewards(VHL, nilPL) 
    	= VHL . 
    eq updateRewards((VHL ; < v(I) , H , X > ; VHL'), [ v(I) , B' ] ; CL) 
    	= updateRewards((VHL ; < v(I) , H , (if B' then X + 2 else X fi) > ; VHL'), CL) .

	---- formProposers(VHL, IL) 
	----    VHL: list of (public) validator records 
	----    IL: list of proposer indices 
	----    Result: The list of proposer records corresponding to IL, where 
	----            the reveal status is initialized to false.
	----
	---- e.g. formProposers(< v(0), H, 0 > ; < v(1), H', 10 >, (1 . 0)) 
	----         = [v(1) , false] ; [v(0), false]
	----
    op formProposers : VRecordList NatList -> [ProposerList] .
    eq formProposers(VHL, nilIL) = nilPL . 
    eq formProposers((VHL ; < v(I) , H , X > ; VHL'), (I . IL)) = [ v(I) , false ] ; formProposers((VHL ; < v(I), H , X > ; VHL'), IL) .

    ---- setNewCVRoles(CVL, IL)
    ----	CVL: list of (private) validator records 
    ----	IL: list of proposer indices 
    ----	Result: The list of (private) validator records CVL in which 
    ----			the roles of the validators appearing in IL are appropriately
    ----            set according to the validator type and position in IL 
    ----
    ---- e.g. Assuming CYCLE-LENGTH = 2, we have 
    ----	setNewCVRoles(< v(0), S0, S0', honest > ; < v(1) , S1, S1' , mtCRS >, (1 . 0))
    ----		  = < v(0), S0, S0', honest > ; <v(1) , S1, S1' , [1 : isolated] >
	----
    ---- e.g. Assuming CYCLE-LENGTH = 4, we have 
    ----	setNewCVRoles(< v(0), S0, S0', honest > ; < v(1) , S1, S1' , mtCRS >, (1 . 0 . 1 . 1))
    ----		  = < v(0), S0, S0', honest > ; 
    ----            < v(1), S1, S1', [1 : isolated], [3 : ctailhead(S1 . S1)],[4 : ctailtail] >
    ----
    op setNewCVRoles : CVRecordList NatList -> [CVRecordList] .
    eq setNewCVRoles(CVL, IL) = setNewCVRoles*(resetRoles(CVL), IL, #CYCLE-LENGTH, true, nilIL) .

    ---- resetRoles(CVL)
    ----	CVL: list of (private) validator records 
    ----    Result: The same list CVL with all attacker roles reset to mtCRS 
    ---- This is a helper function to setNewCVRoles(CVL, IL)
    ----
    op resetRoles : CVRecordList -> [CVRecordList] .
    eq resetRoles(CVL ; < v(I) , S, S', CRS > ; CVL') 
    	= resetRoles(CVL) ; < v(I) , S, S', mtCRS > ; resetRoles(CVL') .
    eq resetRoles(CVL) 
    	= CVL [owise] .

    ---- setNewCVRoles*(CVL, IL, N, B, SDL)
    ----	CVL: list of (private) validator records 
    ----	IL: list of proposer indices 
    ----	N: A natural number (the remaining records in the proposers list) 
    ----	B: A Boolean indicating whether an honest validator has been seen so far
    ---- 	SDL: The list of seeds of the compromized tail of IL collected so far     
    ----    Result: The list of (private) validator records CVL in which 
    ----			the roles of the validators appearing in IL are appropriately
    ----            set according to the validator type and position in IL  
    ---- This is a helper function to setNewCVRoles(CVL, IL)
    ----
    op setNewCVRoles* : CVRecordList NatList Nat Bool NatList -> [CVRecordList] .
    eq setNewCVRoles*(CVL, nilIL, N, B, SDL) 
    	=  CVL . 
    eq setNewCVRoles*((CVL ; < v(I) , S, S', honest > ; CVL'), (IL . I), s(N), T?, SDL) 
    	= setNewCVRoles*((CVL ; < v(I) , S, S', honest > ; CVL'), IL, N, false, SDL) .
    eq setNewCVRoles*((CVL ; < v(I) , S, S', CRS > ; CVL'), (IL . I), s(N), false, SDL) 
    	= setNewCVRoles*((CVL ; < v(I) , S, S', (CRS , [s(N) : isolated]) > ; CVL'), IL, N, false, SDL) .
   ceq setNewCVRoles*((CVL ; < v(I) , S, S', CRS > ; CVL'), (IL . I), s(N), true, SDL) 
    	= if B then 
    		setNewCVRoles*((CVL ; < v(I) , S, S', (CRS , [s(N) : ctailtail]) > ; CVL'), IL, N, true, (S . SDL)) 
    	  else
    		setNewCVRoles*((CVL ; < v(I) , S, S', (CRS , [s(N) : ctailhead(S . SDL)]) > ; CVL'), IL, N, true, (S . SDL)) 
    	  fi
    	if B := isCEnd?((CVL ; < v(I) , S, S', CRS > ; CVL'), IL) .

    ---- isCEnd?(CVL, IL)
    ----	CVL: list of (private) validator records 
    ----    IL : list of proposer indices
    ----    Result: A Boolean indicating whether the end of IL is compromized
    ---- This is a helper function to setNewCVRoles(CVL, IL)
    ---- 
    op isCEnd? : CVRecordList NatList -> [Bool] .
    eq isCEnd?(CVL, nilIL) = false .
    eq isCEnd?((CVL ; < v(I) , S, S', honest > ; CVL'), (IL . I)) = false .
    eq isCEnd?((CVL ; < v(I) , S, S', CRS > ; CVL'), (IL . I)) = true .

    ---- createDoReveals(F, A, N, IL)
    ----	F: the global time value 
    ---- 	A: the RANDAO contract actor name (not really used in this version)
    ----    N : a counter representing the number of messages created so far 
    ----    IL: list of validator indicies 
    ----    Result: A list of scheduled doReveal messages targeted at validators  
    ---- 			in IL with base time value TG 
    ---- 
    ---- e.g. createDoReveals(0.0, r, 3, (2 . 5 . 7)) may rewrite to:
    ---- 			[0.0260136714847790, v(2) <- doReveal(1), 0] ; 
    ----            [1.0773220517922477, v(5) <- doReveal(2), 0] ; 
    ----            [2.0658048222786292, v(7) <- doReveal(3), 0]
    ----      
    op createDoReveals : Float ActorName Nat NatList -> [ScheduleList] .
    eq createDoReveals(TG, RID, N, nilIL) = nil .
    eq createDoReveals(TG, RID, N, I . IL) = [TG + float(N) + #TRANSMISSION-DELAY, (v(I) <- doReveal(s(N))), #MSG-DROP-PROB] ; createDoReveals(TG, RID, s(N), IL) .


	****************************************
	**** The Rules
	**************************************** 

	---- RAdvanceSlot: Advance the process to the next slot
	---- This rule processes a message of the form nextSlot(L), which initiates
	---- the process of advancing the state of the protocol to the next slot. 
	---- Assuming K is the next slot number to be processed as recorded in the
	---- state of the RANDAO contract object, there are three cases:
	---- Case 1: L > #CYCLE-LENGTH, which means that the protocol has already
	----	processed the end of the #CYCLE-LENGTH proposers for the current 
	----    round, and progressing to the next slot would require advancing the
	----    the current round of the game first. The RANDAO contract object 
	---- 	changes its status to 'processing', samples a new proposers list
	---- 	using its stored computed seed, and resets the slot count back to 1. 
	---- 	It also emits a zero-delay 'nextRound' message to continue its 
	----    preparation for the following round of the game. 
	---- Case 2: L == K, which means that slot number was already advanced by
	---- 	successfully processing a reveal. In this case, the state is not
	---- 	changed and a 'nextSlot' message is scheduled as normal.
	---- Case 3: L > K, which means the slot number was not advanced before
	----	and thus, either a reveal was attempted but failed or that a reveal
	----    was never received. In both cases, the RANDAO object records that 
	----	as a failure in the proposers record list and advances the slot 
	----	number. It also schedules a 'nextSlot' message for the next slot. 
	----
 rl [RAdvanceSlot] :
 	limit(true, D)
 	<name: BID |		
			seed:           S, 
			vappr-size:     N,
			vpending-size:	N',
			AS >
 	<name: RID |		
			status:	ready, 
			proposers:	([ VID , B ] ; CL),
			prop-ilist: IL,       
			pnext:	K,
			AS' >
    { TG | SL }
    (RID <- nextSlot(L))
    => limit(TG <= #SIM-TIME-LIMIT * D, D)
    	<name: BID |		
				seed:           S, 
				vappr-size:     N,
				vpending-size:	N',
				AS >
    	if L > #CYCLE-LENGTH then
    		---- End of game round: prepare to advance to the next round 
 			<name: RID |		
					status:	processing, 
					proposers:	([ VID , B ] ; CL),       
					prop-ilist: computeNewNatList(N + N', #CYCLE-LENGTH, S),       
					pnext:	1,
					AS' >
    		{ TG | SL }
    		(RID <- nextRound)
    	else 
    		if L == K then 
    			---- Slot was already advanced by a valid reveal -- so no changes 
 				<name: RID |		
						status:	ready, 
						proposers:	([ VID , B ] ; CL),       
						prop-ilist: IL,       
						pnext:	K,
						AS' >
			else
				---- Slot was not advanced -- advance it and record failure of a reveal
 				<name: RID |		
						status:	ready, 
						proposers:	(CL ; [ VID , false ]),       
						prop-ilist: IL,       
						pnext:	s(K),
						AS' >
			fi 
			mytick(insert({ TG | SL }, [floor(TG) + 1.0, (RID <- nextSlot(s(L))), 0])) 
		fi
    	[print TG ": RAdvanceSlot: from " K " to " L] .

    ---- RAdvanceRound: Advance the process to the next round 
    ---- This rule processes a 'nextRound' message. Several steps are taken in this 
    ---- transition:
    ---- 1. The (public) validator records VHL are updated to reward those who have 
    ----    successfully reveled their seeds in the last round (with updateRewards).
    ---- 2. The pending validators list VHL' is incorporated into the approved list
    ----    in preparation for their participation in the next round and the list 
    ----    sizes are updated accordingly.
    ---- 3. Given the freshly sampled list of proposer indices IL, the list (private)
    ----    validator records for the compromized validators are updated with 
    ----    potentially new attacker roles (with setNewCVRoles).  
    ---- 4. Given the freshly sampled list of proposer indices IL, a new proposers
    ----    list is created and initialized (with formProposers) 
    ---- 5. A new list of 'doReveal' messages is created and inserted into the 
    ----    scheduler, along with a 'nextSlot' message to resume advacning rounds.
    ----
  rl [RAdvanceRound] :
 	limit(true, D)
 	round(R)
 	<name: BID |		
			vappr:          VHL,
			vappr-size:		N,
			vpending:		VHL',
			vpending-size:	N', 
			AS >
	<name: a   |
			vcomp: 			CVL,
			AS' >
 	<name: RID |		
			status:			processing, 
			balance: 		J,
			success-rounds: I, 
			proposers:      CL,
			prop-ilist:		IL, 
			prop-size:     	M,
			pnext:          K,
			AS'' >
    { TG | SL }
    (RID <- nextRound)
    =>  limit(TG <= #SIM-TIME-LIMIT * D, D)
    	round(R + 1.0)
	 	<name: BID |		
				vappr:          (updateRewards(VHL, CL) ; VHL'), 
				vappr-size:		(N + N'),
				vpending:		nilVHL,
				vpending-size:	0, 
				AS >
		<name: a   |
				vcomp: 			setNewCVRoles(CVL, IL),
				AS' >
 		<name: RID |		
				status:			ready, 
				balance: 		J,
				success-rounds: s(I), 
				proposers:      formProposers(VHL ; VHL', IL),
				prop-ilist:		IL, 
				prop-size:     	M,
				pnext:          1,
				AS'' >
		mytick(insertList(insert({ TG | SL }, [floor(TG) + 1.0, (RID <- nextSlot(2)), 0]), createDoReveals(TG, RID, 0, IL))) 
    	[print TG ": RAdvanceRound with new committee " IL] .


    ---- RProcessReveal: Process an incoming reveal message 
    ---- This rule processes a 'reveal' message sent by a proposer. There are
    ---- two cases:
    ---- 1. The reveal is successful (the commit check is successful), in which
    ----    case (1) the new seed is computed (using combineSeeds which XORs the 
    ----    currently stored seed with the revealed seed), (2) the fact that the 
    ----    reveal was successful is recorded in the proposers record, and (3)
    ----    the slot counter is incremented. 
    ---- 2. The reveal is not successful, in which case the failure is recorded
    ----    int the proposers record list.
    ---- In both cases, no new message is scheduled.
    ----
 rl [RProcessReveal] :
 	limit(true, D)
 	<name: BID |		
			seed:	RS,  
			vappr:	(VHL ; < VID, H , X > ; VHL') ,   
			AS >
 	<name: RID |		
			status:	ready, 
			proposers:	([ VID , B ] ; CL),       
			pnext:	J,
			AS' >
    { TG | SL }
    (RID <- reveal(VID, S, H'))
    => limit(TG <= #SIM-TIME-LIMIT * D, D)
    	if (H == h(S)) then 
    		---- The reveal is successful
		 	<name: BID |		
					seed:	combineSeeds(RS, S),  
					vappr:	(VHL ; < VID, H' , X > ; VHL') ,   
					AS >
 			<name: RID |		
					status:	ready, 
					proposers:	(CL ; [ VID , true ]),       
					pnext:	s(J),
					AS' >
		else
    		---- The reveal failed
		 	<name: BID |		
					seed:	RS,  
					vappr:	(VHL ; < VID, H , X > ; VHL') ,   
					AS >
 			<name: RID |		
					status:	ready, 
					proposers:	(CL ; [ VID , false ]),       
					pnext:	J,
					AS' >
		fi 
    	mytick({ TG | SL }) 
    	[print TG ": RProcessReveal received from " VID] .
endm
 
***(
*** Validator Actions
***
*** This module defines how the validators (both honest and compromized) behave. 
*** There are essentially two validator actions, which we specify here using a 
*** total of 5 rules to maintain clarity of presentation (2 rules would 
*** technically be sufficient, but would result in structurally complicated rules).
*** 1. Revealing a seed: specified by 
***		- VHonestReveal: for honest validators
***     - VCompReveal1: for compromized validators with role 'isolated'
*** 	- VCompReveal2: for compromized validators with role 'ctailtail'
*** 	- VCompReveal3: for compromized validators with role 'ctailhead'
*** 2. Arriving to the system: specified by 
***		- VArrive
***
)
mod VALIDATOR-BEHAVIOR is
	protecting CONFIG .
	protecting PARAMS .

	vars S S' RS PS : Seed .
	vars AS AS' AS'' : AttributeSet . 
	vars T TG TS TS' TR TR' D R F : Float .
	vars SL SL' : ScheduleList . 
	vars CID VID RID OID AID BID VGID : ActorName .
  	vars H : Hash .
	vars I J K L M M' N N' : Nat .
	vars VHL VHL' : VRecordList .
	vars CVL CVL' : CVRecordList .
	vars CL : ProposerList .
	vars C : Content .
	vars B : Bool .
	vars IL : NatList .
	vars X : Int .
	vars RO : Role .
	vars CRS : CRoleSet . 
	vars ST ST' : Strategy .
	vars SSTL STL STL' : StrategyList .
	vars CP : CPosition .
	vars SKL SKL' : SkipList .
	vars SDL : NatList .

	****************************************
	**** Some Operations Needed by the Rules
	**************************************** 

	---- preComputeSeed(RS, SDL, SKL)
	---- 	RS: the starting seed
	----	SDL: a list of seeds
	---- 	SKL: a skip list (a list of Boolean values indicating whether to reveal 
	----		 or skip at each slot)
	---- 	Result: The seed that would be computed by RANDAO if the seeds in SDL 
	----  			and the skips in SKL are used
	----
	---- e.g. preComputeSeed(8479, 487734 . 93478 . 4931, true . false . true) = 476010
	----
	op preComputeSeed : Seed NatList SkipList -> [Seed] .
	eq preComputeSeed(RS, SDL, nilSKL) = RS .
	eq preComputeSeed(RS, (S . SDL), (B . SKL))
		= preComputeSeed(if B then combineSeeds(RS, S) else RS fi, SDL, SKL) .	
	
	---- computeAllScores(IL, STL, RS, SDL, N, M) 
	----    IL: list of all compromized validator indicies 
	----    STL: list of attack strategies for which scores are to be computed
	----  	RS: The RANDAO-computed seed
	----    SDL: the list of (compromized) validator seeds
	----  	N: the total number of validators in the system
	----   	M: the number of proposers (#CYCLE-LENGTH) 
	----    Result: The strategy list STL in which each strategy is assigned
	----            a score 
	---- Note 1: Scoring is based on the scoring function specified by #SCORE-FUNCTION
	----
	---- e.g. computeAllScores(
	---- 		1 . 3 . 5 . 7 . 9, 
	----		[0 : true . false . true] [0 : true . false . false], 
	----        8479, 
	----        487734 . 93478 . 4931, 
	----        15, 
	----        4) .
	---- may rewrite to: 
	----		[0 : true . false . true] [2 : true . false . false]
	----
	op computeAllScores : NatList StrategyList Seed NatList Nat Nat -> [StrategyList] .
	eq computeAllScores(IL, nilSTL, RS, SDL, N, M) = nilSTL .
	eq computeAllScores(IL, (ST STL), RS, SDL, N, M) 
		= computeScore(IL, ST, RS, SDL, N, M) computeAllScores(IL, STL, RS, SDL, N, M) .

	--- computeScore(IL, ST, RS, SDL, N, M)
	--- Similar to above, except that it computes the score of exactly one strategy ST.
	--- It is called by computeAllScores on each ST in the list of strategies STL. This 
	--- is a helper function to computeAllScores. It uses both preComputeSeed and 
	--- computeScoreFunction.
	op computeScore : NatList Strategy Seed NatList Nat Nat -> [Strategy] .
	ceq computeScore(IL, [I : B . SKL], RS, SDL, N, M) 
		= [K : B . SKL]
		if  PS := preComputeSeed(RS, SDL, B . SKL)
 		/\	K := computeScoreFunction(
					#SCORE-FUNCTION,
					computeNewNatList(N, M, PS), 
					IL) . 

	---- findMaxScoreStrat(STL)
	---- 	STL: A list of strategies (with scores)
	---- 	Result: Returns the (first) strategy having the maximum score 
	----
	---- e.g. findMaxScoreStrat(
	----			[1 : true . false]  
	---- 			[3 : false . true] 
	---- 			[2 : false . false]) 
	----		= [3 : false . true] 
	---- 
	op findMaxScoreStrat : StrategyList -> [Strategy] .
	eq findMaxScoreStrat(ST STL) = findMaxScoreStrat*(STL, ST) .

	---- findMaxScoreStrat*(STL, ST)
	---- A helper function to findMaxScoreStrat that maintains the (first found)
	---- maximum-score strategy as an argument (tail-recursive function) 
	op findMaxScoreStrat* : StrategyList Strategy -> [Strategy] .
	eq findMaxScoreStrat*(nilSTL, ST) = ST .
	eq findMaxScoreStrat*([I : SKL] STL, [K : SKL']) 
		= if I > K then 
			findMaxScoreStrat*(STL, [I : SKL])
		  else 
			findMaxScoreStrat*(STL, [K : SKL'])
		  fi .


	****************************************
	**** The Rules 
	**************************************** 

	---- VHonestReveal: An honest validator revealing the seed and making a commit 
	----
	---- This rule models the behavior expected from an honest validator. The validator 
	---- consumes the doReveal message and schedules a reveal message back to the RANDAO
	---- actor object having its name, the revealed seed, and the hash of the next-round
	---- seed. In preparation for future rounds, the validator updates its state and 
	---- generates a new seed to be used later on.
	----  
  rl [VHonestReveal] : 
    limit(true, D)
	<name: AID |
			vcomp:	(CVL ; < VID , S, S', honest > ; CVL'),  
			vcomp-ilist: IL, 
			AS >
 	<name: BID |		
			vappr:	(VHL ; < VID, H , X > ; VHL') ,   
			AS' >    	
    { TG | SL }
    (VID <- doReveal(K))
    => limit(TG <= #SIM-TIME-LIMIT * D, D)
		<name: AID |
				vcomp:	(CVL ; < VID , S', sampleUniWithInt(#MAX-SEED-VALUE), honest > ; CVL'),  
				vcomp-ilist: IL, 
				AS >
 		<name: BID |		
				vappr:	(VHL ; < VID, H , X > ; VHL') ,   
				AS' >    	
			mytick(insert( { TG | SL }, [ TG + #TRANSMISSION-DELAY, (r <- reveal(VID, S, h(S'))) , #MSG-DROP-PROB] ))
	[print TG ": VReveal by " VID] .

	---- VCompReveal1: A compromized validator with role "isolated" possibly revealing a seed
	----
	---- This (conditional) rule models the behavior of a compromized validator with role 
	---- 'isolated' (a validator that deos not belong to the compromized tail of the proposers 
	---- list. The validator consumes the doReveal message and computes the score of
	---- revealing the seed using computeScoreFunction. The score is compared with the 
	---- #MIN-ATTACK-SCORE, the minimum score value deemed acceptable by the attacker.
	---- If the score is below the minimum acceptable, the validator remains silent (does
	---- not schedule a reveal message) and the state remains unchanged. Otherwise, the 
	---- validator schedules a reveal message back to the RANDAO actor object having its name
	---- the revealed seed, and the hash of the next-round seed. Additionally, the validator  
	---- updates its state and generates a new seed to be used later on.
	----
	---- Recall that the score is determined by the score function the attacker is trying to
	---- optimize for (maximizing the number of the compromized validators or maximizing the
	---- the number of validators in the compromized tail).
 crl [VCompReveal1] : 
    limit(true, D)
 	<name: BID |		
			seed:	RS,  
			vappr-size: N,
			vappr:	(VHL ; < VID, H , X > ; VHL') ,   
			AS >
	<name: AID |
			vcomp:	(CVL ; < VID , S, S', ([ K : isolated], CRS) > ; CVL'),  
			vcomp-ilist: IL, 
			AS' >    
	{ TG | SL }
    (VID <- doReveal(K))
    => limit(TG <= #SIM-TIME-LIMIT * D, D)
		if B then 
 		<name: BID |		
				seed:	RS,  
				vappr-size: N,
				vappr:	(VHL ; < VID, H , X > ; VHL') ,   
				AS >
		<name: AID |
				vcomp:	(CVL ; < VID , S', sampleUniWithInt(#MAX-SEED-VALUE), ([ K : isolated], CRS) > ; CVL'),  
				vcomp-ilist: IL, 
				AS' >  
			mytick(insert( { TG | SL }, [ TG + #TRANSMISSION-DELAY, (r <- reveal(VID, S, h(S'))) , #MSG-DROP-PROB] ))
 		else
 		<name: BID |		
				seed:	RS,  
				vappr-size: N,
				vappr:	(VHL ; < VID, H , X > ; VHL') ,   
				AS >
		<name: AID |
				vcomp:	(CVL ; < VID , S, S', ([ K : isolated], CRS) > ; CVL'),  
				vcomp-ilist: IL, 
				AS' >  
			mytick({ TG | SL })
	    fi
		if B := computeScoreFunction(
					#SCORE-FUNCTION, 
					computeNewNatList(N, #CYCLE-LENGTH, combineSeeds(RS, S)),
					IL) >= #MIN-ATTACK-SCORE
		[print TG ": VCompReveal1 for slot " K " by " VID " => " B] .

	---- VCompReveal2: A compromized validator with role "ctailtail" possibly revealing a seed
	----
	---- This rule models the behavior of a compromized validator with role 'ctailtail' (a 
	---- compromized validator that belongs to the compromized tail but is not the head of 
	---- this tail). The validator consumes the doReveal message and then checks whether 
	---- it should reveal or not according to the precomputed strategy of the attacker. If
	---- B in the strategy (B . SKL) is true, the validator reveals (schedules a reveal messsage
	---- as described above). Otherwise, if B is false, the validator remains silent. Other 
	---- updates to the state are similar to the above rules. 
 rl [VCompReveal2] : 
    limit(true, D)
 	<name: BID |		
			seed:	RS,  
			vappr-size: N,
			vappr:	(VHL ; < VID, H , X > ; VHL') ,   
			AS >    
	<name: AID |
			vcomp:	(CVL ; < VID , S, S', ([ K : ctailtail], CRS) > ; CVL'),   
			strategy: [J : B . SKL],
			vcomp-ilist: IL, 
			AS' >    
	{ TG | SL }
    (VID <- doReveal(K))
    => limit(TG <= #SIM-TIME-LIMIT * D, D)
		if B then 
 			<name: BID |		
				seed:	RS,  
				vappr-size: N,
				vappr:	(VHL ; < VID, H , X > ; VHL') ,   
				AS >
			<name: AID |
				vcomp:	(CVL ; < VID , S', sampleUniWithInt(#MAX-SEED-VALUE), ([ K : ctailtail], CRS) > ; CVL'),  
				strategy: [J : SKL],
				vcomp-ilist: IL, 
				AS' >  
			mytick(insert( { TG | SL }, [ TG + #TRANSMISSION-DELAY, (r <- reveal(VID, S, h(S'))) , #MSG-DROP-PROB] ))
 		else
 			<name: BID |		
				seed:	RS,  
				vappr-size: N,
				vappr:	(VHL ; < VID, H , X > ; VHL') ,   
				AS >
			<name: AID |
				vcomp:	(CVL ; < VID , S, S', ([ K : ctailtail], CRS) > ; CVL'),  
				strategy: [J : SKL],
				vcomp-ilist: IL, 
				AS' >  
			mytick({ TG | SL })
	    fi
		[print TG ": VCompReveal2 for slot " K " by " VID " => " B] .	    	

	---- VCompReveal3: A compromized validator with role "ctailhead" possibly revealing a seed
	----
	---- This rule models the behavior of a compromized validator with role 'ctailhead' (a 
	---- compromized validator that is at the head of the compromized tail. The validator  
	---- consumes the doReveal message and then performs the following steps:
	----	1. It enumerates all possible attack strategies relevant to its position in the 
	----	   proposers list (enumStrategies) 
	----	2. It then computes the scores of all the enumerated strategies given the current
	----	   RANDAO seed and the seeds of all ctailtail validators (computeAllScores) 
	----	3. Finally, it finds the strategy with the maximum score (B . SKL') and updates the  
	----	   state to record that strategy (findMaxScoreStrat)
	---- The validator now applies this strategy by checking B. If B is true, the validator 
	---- reveals. Otherwise, if B is false, the validator remains silent. Other updates are 
	---- similar to the above rules. 
	----
 crl [VCompReveal3] : 
    limit(true, D)
 	<name: BID |		
			seed:	RS,  
			vappr-size: N,
			vappr:	(VHL ; < VID, H , X > ; VHL') ,   
			AS >    
	<name: AID |
			vcomp:	(CVL ; < VID , S, S', ([ K : ctailhead(SDL)], CRS) > ; CVL'),   
			strategy: [J : SKL],
			vcomp-ilist: IL, 
			AS' >    
	{ TG | SL }
    (VID <- doReveal(K))
    => limit(TG <= #SIM-TIME-LIMIT * D, D)
		if B then 
 			<name: BID |		
				seed:	RS,  
				vappr-size: N,
				vappr:	(VHL ; < VID, H , X > ; VHL') ,   
				AS >
			<name: AID |
				vcomp:	(CVL ; < VID , S', sampleUniWithInt(#MAX-SEED-VALUE), ([ K : ctailhead(SDL)], CRS) > ; CVL'),  
				strategy: [I : SKL'],
				vcomp-ilist: IL, 
				AS' >  
			mytick(insert( { TG | SL }, [ TG + #TRANSMISSION-DELAY, (r <- reveal(VID, S, h(S'))) , #MSG-DROP-PROB] ))
 		else
 			<name: BID |		
				seed:	RS,  
				vappr-size: N,
				vappr:	(VHL ; < VID, H , X > ; VHL') ,   
				AS >
			<name: AID |
				vcomp:	(CVL ; < VID , S, S', ([ K : ctailhead(SDL)], CRS) > ; CVL'),  
				strategy: [I : SKL'],
				vcomp-ilist: IL, 
				AS' >  
			mytick({ TG | SL })
	    fi
	if STL        := enumStrategies(s(#CYCLE-LENGTH - K))
	/\ SSTL       := computeAllScores(IL, STL, RS, SDL, N, #CYCLE-LENGTH)
	/\ [I : B . SKL'] := findMaxScoreStrat(SSTL)
	[print TG ": VCompReveal3 for slot " K " by " VID " with strategy " B " . " SKL'] .	    	


	---- VArrive: A new validator requesting to join the system 
	----
	---- This rule models the arrival of a fresh validator into the system. 
	---- Upon receiving the 'spawn' message, the validator generator creates
	---- new validator records and adds them to the pending list of validators,
	---- and the size of pending validators is incremented. If the validator is 
	---- compromized (controlled by the attacker), the list of (private) 
	---- validator records is also augmented, and the list of compromized 
	---- validator indices and its size are updated accordingly. In any case, 
	---- The generator updates its state by preparing the index, seed and the
	---- compromized state of the next freah validator to be generated, and
	---- schedules another 'spawn' message delayed by the validator arrival
	---- delay.
	----  
  rl [VArrive] : 
    limit(true, D)
	<name: BID |												
		vpending:       VHL, 
		vpending-size:  M,
		AS >
    <name: AID  | 
    	vcomp: CVL, 
		vcomp-ilist: IL, 
    	vcomp-size: M', 
    	AS' >  								
    <name: VGID |
	    	vcount: N, 
	    	contract: RID,
	    	next-seed: S,
		   	next-comp: B,
	    	AS'' >
    { TG | SL }
    (vg <- spawn)
    => limit(TG <= #SIM-TIME-LIMIT * D, D)
		<name: BID |												
			vpending:       (VHL ; < v(N), h(S) , (- #DEPOSIT-SIZE) >), 
			vpending-size:  s(M),
			AS >
		if B then
	    	<name: AID  | 
	    		vcomp: (CVL ; < v(N), S, sampleUniWithInt(#MAX-SEED-VALUE), mtCRS >), 
				vcomp-ilist: (IL . N), 
	    		vcomp-size: s(M'), 
	    		AS' >  								
	    else
	    	<name: AID  | 
	    		vcomp: (CVL ; < v(N), S, sampleUniWithInt(#MAX-SEED-VALUE), honest >), 
				vcomp-ilist: IL, 
	    		vcomp-size: M', 
	    		AS' >  			
	    fi 					
    	<name: VGID |
		    	vcount: s(N), 
		    	contract: RID,
		    	next-seed: sampleUniWithInt(#MAX-SEED-VALUE),
		    	next-comp: sampleBerWithP(#ATTACK-PROB),
	    		AS'' >
		mytick(insert( { TG | SL }, 
			[ TG + #VALIDATOR-ARRIVAL-DELAY, (VGID <- spawn) , 0]))
	[print TG ": VArrive: s(" N ")"] .
endm

mod INIT-STATE is
	protecting VALIDATOR-BEHAVIOR .
	protecting RANDAO-BEHAVIOR .

	vars I J M N K : Nat .
	vars S S' : Seed .
	vars RID VID AID : ActorName .
	vars VHL VHL' : VRecordList .
	vars CVL CVL' : CVRecordList .
	vars AS AS' AS'' : AttributeSet .
	vars VC : Config .
	vars B : Bool .
	var X : Int .
	vars IL : NatList .
	vars RO : Role .
	vars CRS : CRoleSet .

	---- makeVL(N): Generates a list of size N of (empty) public validator records 
	----
	---- e.g. makeVL(3) = < v(0),h(0),-32 > ; < v(1),h(0),-32 > ; < v(2),h(0),-32 >
	---- 
	op makeVL : Nat -> [VRecordList] .
	eq makeVL(0) = nilVHL .
	eq makeVL(s(N)) = makeVL(N) ; < v(N), h(0) , (- #DEPOSIT-SIZE) > .


	---- makeCVL(N): Generates a list of size N of (empty) private validator records 
	----
	---- e.g. makeCVL(3) may rewrite to
	---- 		< v(0), 2156527062, 1120604416, honest > ; 
	---- 		< v(1), 3376653905, 764202170,  honest > ; 
	---- 		< v(2), 3212733452, 2663109851, mtCRS >
	---- 
	op makeCVL : Nat -> [CVRecordList] .
	eq makeCVL(0) = nilCVL .
	eq makeCVL(s(N)) 
		=  makeCVL(N) ; 
			< v(N), 
			  random(counter), 
			  random(counter), 
			  if sampleBerWithP(#ATTACK-PROB) then mtCRS else honest fi 
			> .

	---- createInitDoReveals(IL, N): Generates a list of N scheduled elements containing 
	---- 'doReveal' messages targeted to validators whose indices are given in IL (we 
	---- assume N > length(IL)) 
	----
	---- e.g. createInitDoReveals(0 . 1 . 2, 3) =
	---- 		[0.01, v(0) <- doReveal(1), 0] ; 
	---- 		[1.01, v(1) <- doReveal(2), 0] ; 
	---- 		[2.01, v(2) <- doReveal(3), 0]
	---- 
	op createInitDoReveals : NatList Nat -> [ScheduleList] .
	eq createInitDoReveals(nilIL, N) 
		= nil .
	eq createInitDoReveals(IL . I, s(N)) 
		= createInitDoReveals(IL, N) ; [0.01 + float(N), (v(I) <- doReveal(s(N))) , #MSG-DROP-PROB] .


	---- initBlockchain(N): Initialize the Blockchain object with N validator records
	op initBlockchain : Nat -> [Object] .
	eq initBlockchain(N) = 
		<name: bc |												---- The Blockchain Object
			seed:           sampleUniWithInt(#MAX-SEED-VALUE),  ---- seed of previous game round
			vpending:       nilVHL,             				---- list of pending validators 
			vpending-size:  0,                  				---- their count
			vappr:          makeVL(N),     						---- list of approved validators (as public validator records) 
			vappr-size:     N           						---- their count
		> .

	---- initAttacker(N): Initialize the Attacker object with N validator records
	op initAttacker : Nat -> [Object] .
	eq initAttacker(N) = 
		<name: a |								---- The Attacker Object
			vcomp:			makeCVL(N),       	---- Private validator records
			vcomp-ilist:	nilIL,				---- list of compromized validator indices
			vcomp-size:		0,           		---- their count
			strategy:		[0 : nilSKL]		---- the attacker's strategy 
		> .	

	---- initRandao(M, N, K): Initialize the RANDAO object with N validator records,
	---- M proposers and a deposit-per-validator given by K 
	op initRandao : Nat Nat Nat -> [Object] .
	eq initRandao(M, N, K) =
		<name: r |								---- The RANDAO Contract
			status:         ready,              ---- status can be 'ready' or 'processing'
			balance:        (N * K),       		---- current contract balance 
			success-rounds: 0,                  ---- number of successful rounds
			proposers:      nilPL, 				---- proposers participating in the current game round
			prop-size:      M,                  ---- their count (in the steady state, this must be equal to #PROP-SIZE)
			prop-ilist: 	nilIL, 				---- their indices,       
			pnext:          1                   ---- next validator (time slot) to process
		> .

	---- initVGen(N, A): Initialize the validator generator object with N 
	---- as the next index, and A as the RANDAO object name 
	op initVGen : Nat ActorName -> [Object] .
	eq initVGen(N, RID) = 
		<name: vg | 
			vcount: N, 
			contract: RID,
			next-seed: sampleUniWithInt(#MAX-SEED-VALUE),
			next-comp: sampleBerWithP(#ATTACK-PROB) > .

	---- initState: Generate the initial state of the protocol
	rl initState =>
		initSystem(
			initProposers(
				initBlockchain(#INIT-VLIST-SIZE)
				initAttacker(#INIT-VLIST-SIZE)
				initRandao(#CYCLE-LENGTH, #INIT-VLIST-SIZE, #DEPOSIT-SIZE)
				, #INIT-VLIST-SIZE, #CYCLE-LENGTH
		), #INIT-VLIST-SIZE
	) .

	---- initProposers(C, N, M): A helper function to initialize (in two steps)  
	---- the proposers list in the configuration C, given N as the total number  
	---- of validators in the system and M as the number of proposers

	---- The first step is to generate the list of proposer indices
	op initProposers : Config Nat Nat -> [Config] .
	eq initProposers(
		<name: bc | seed: S, AS >
		<name: r  |	prop-ilist: nilIL, AS' >        
		VC, N, M) 
		= initProposers(
			<name: bc | seed: S, AS >  
			<name: r  | prop-ilist: computeNewNatList(N, M, S), AS' >        
			VC, N, M) .

	---- The second step is form the list of proposer records 
	eq initProposers(
		<name: bc | vappr: VHL, AS >  
		<name: r  |	prop-ilist: (I . IL), proposers: nilPL, AS' >        
		VC, N, M) 
		= <name: bc | vappr: VHL, AS >  
		  <name: r  | prop-ilist: (I . IL), proposers: formProposers(VHL, (I . IL)), AS' >        
		  VC .

	---- initSystem(C, I): A helper function to initialize all validator records and the 
	---- configuration as a whole. The function walks through the set of validators, one-
	---- by-one updating their records. 

	---- If the validator is honest: Initialize its records 
	op initSystem : Config Nat -> [Config] .
	eq initSystem(
			<name: bc    | vappr: (VHL ; < v(I), h(0), X >   ; VHL'), AS > 	
			<name: a     | vcomp: (CVL ; < v(I), S, S', honest > ; CVL'), vcomp-ilist: IL, vcomp-size: N, AS' > 								
			VC, s(I))
		= initSystem(
				<name: bc    | vappr: (VHL ; < v(I), h(S), X >   ; VHL'), AS > 	
				<name: a     | vcomp: (CVL ; < v(I), S, S', honest > ; CVL'), vcomp-ilist: IL, vcomp-size: N, AS' > 								
				VC, I) .
	---- If the validator is compromized: Initialize its records and update the compromized 
	---- validator list 
	eq initSystem(
			<name: bc    | vappr: (VHL ; < v(I), h(0), X >   ; VHL'), AS > 	
			<name: a     | vcomp: (CVL ; < v(I), S, S', CRS > ; CVL'), vcomp-ilist: IL, vcomp-size: N, AS' > 								
			VC, s(I))
		= initSystem(
				<name: bc    | vappr: (VHL ; < v(I), h(S), X >   ; VHL'), AS > 	
				<name: a     | vcomp: (CVL ; < v(I), S, S', CRS > ; CVL'), vcomp-ilist: (I . IL), vcomp-size: s(N), AS' > 								
				VC, I) .
	---- Once done with all validators, return the updated configuration agumented with
	---- the other configuration components (limit, round, validator generator, ... )
	eq initSystem(
			<name: r | prop-ilist: IL, prop-size: M, AS > 
			<name: bc | vappr: VHL, AS' > 	
			<name: a | vcomp: CVL, AS'' > 
			VC, 0) 
		= limit(false, 0.0)
		  round(1.0)
		  <name: r | prop-ilist: IL, prop-size: M, AS > 
		  <name: bc | vappr: VHL, AS' > 	
		  <name: a | vcomp: setNewCVRoles(CVL, IL), AS'' > 
		  VC 
		  if #DYNAMIC-VLIST? then
			initVGen(#INIT-VLIST-SIZE, r)
			mytick(insertList({ 0.0 | createInitDoReveals(IL, M) }, [1.0, r <- nextSlot(2), #MSG-DROP-PROB] ; [#VALIDATOR-ARRIVAL-DELAY, vg <- spawn, 0] )) 		  	
		  else
			mytick(insert({ 0.0 | createInitDoReveals(IL, M) }, [1.0, r <- nextSlot(2), #MSG-DROP-PROB])) 
		  fi .
endm


mod ANALYSIS-INTERFACE is
	protecting INIT-STATE .

    vars C : Config .
    vars B : Bool .
    vars D : Float .
    vars AID RID : ActorName .
    vars CVL : CVRecordList .
    vars AS AS' : AttributeSet .
    vars IL IL' : NatList .

    *******************************************************************
    ***** 0. matchScore: the number of compromised proposers in the 
    *****    proposers list
    *******************************************************************
    op matchScore : Config -> Float .
    eq matchScore(
		<name: AID | vcomp-ilist: IL, AS >  
		<name: RID | prop-ilist: IL', AS' >  
		C )
      = float(countCompromized(IL', IL)) .

    *******************************************************************
    ***** 1. lastWordScore: the length of the compromised tail (last 
    *****    revealers) of the proposers list
    *******************************************************************
	op lastWordScore : Config -> Float .
    eq lastWordScore(
		<name: AID | vcomp-ilist: IL, AS >  
		<name: RID | prop-ilist: IL', AS' >  
		C )
      = float(countCompromizedTail(IL', IL)) .


	***** to be used by PVeStA

	---- D is the game round number 
	---- B is a flag indicating whether the *macro tick* (or game round in this case) is ongoing
	---- tick is PVeStA's step 
    eq tick(limit(B, D) C) =  limit(true, D + 1.0) C .

    eq val(0, C) = matchScore(C) .
    eq val(1, C) = lastWordScore(C) .
endm










        
