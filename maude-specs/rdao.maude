***(
*** Part of rdao-smc: A probabilistic rewriting model of RANDAO schemes
*** 
*** Musab A. Alturki
*** September 2018
*** Runtime Verifcation Inc. 
)

--- import the global paramters defined in rdao-params.maude
load rdao-params.maude

***( 
*** Hash Module
***
*** This modules defines a very high-level abstraction of hashes and 
*** and hash operations. We note that this level of abstraction is 
*** enough for our purposes as we do not deal with the internals of
*** hashing, and simply assume that cryptographically secure hash 
*** functions are used.
***
)
mod HASH is
	protecting PARAMS .
	protecting NAT .

	---- Seeds are represented by naturals
	sort Seed .
	subsort Nat < Seed .

	vars S S' : Seed .

	---- Combining (XOR'ing) seeds to get a new one 
	---- #MAX-SEED-VALUE is taken to be the maximum value that can be 
	---- generated by the random funciton of Maude (This upper bound is 
	---- not really necessary but is there for efficiency)
	op combineSeeds : Seed Seed -> [Seed] .
	eq combineSeeds(S, S') = (S xor S') rem #MAX-SEED-VALUE .


	---- Hash datatype
	sort Hash .
	---- A hash is a seed wrapped by the hash operator (a constructor)
	---- e.g. if S is a seed, its hash is given by h(S)
	op h : Seed -> Hash [ctor frozen] .

	---- Relevant operations and properties of hashing

	---- The Commit operation
	---- Committing on a seed returns the hash of that seed 
	op commit : Seed -> Hash .
	eq commit(S) = h(S) .

	---- The Reveal operation
	---- Revealing on a hash of a seed exposes that seed 
	op reveal : Hash -> Seed .
	eq reveal(h(S)) = S .

endm


***( 
*** Nat Sets
***
*** This modules defines a set of natural numnbers using an associative,
*** commutative and idempotent comma operator with identity mtIS. 
***  
*** e.g. 4 , 0 , 2 , 4 , 10 = 0 , 2 , 4 , 10 is a valid set of naturals
***
)
mod NATSET is
	protecting NAT .

	---- The set of naturals data type 
	sort NatSet .
	---- A natural number is a (singlton) set of naturals
	subsort Nat < NatSet .

	---- Set constructors
	op mtIS : -> NatSet [ctor] .
	op _,_ : NatSet NatSet -> NatSet [ctor assoc comm id: mtIS] .

	---- idempotency 
	eq I:Nat , I:Nat = I:Nat .
endm

***( 
*** Nat Lists
***
*** This modules defines a list of natural numnbers using an associative
*** dot operator. Lists of naturals are heavily used by the model to 
*** represent lists of validator object identifiers (identifiers of
*** validator objects will be defined as wrapped natural numbers).
***  
*** e.g. 4 . 0 . 2 . 4 . 10 is a valid list of naturals
***
)

mod NATLIST is
	extending HASH .
	protecting NATSET .
	protecting SAMPLER .

	---- The list of naturals datatype
	sort NatList .
	---- A natural number is a (degenarate) list of naturals
	subsort Nat < NatList .

	---- List constructors
	op nilIL : -> NatList [ctor] .
	op _._ : NatList NatList -> NatList [ctor assoc id: nilIL] .

	---- Operations on lists:
	vars I M N K : Nat .
	vars S : Seed . 
	vars IL IL' IL1 IL1' IL2 IL2' : NatList .

	---- sampleIndexList(N, M, S): 
	---- 	N: the (current) total number of approved validators in the system 
	----    M: the CYCLE-LENGTH (the number of proposers in the proposer list)
	----    S: the (starting) seed to be used in computing the list of numbers 
	----    Result: Returns a list of indices (natural numbers) computed using  
	----            the sequence of seeds S, S+1, ... , S+(M-1)
	----    Note: In an actual implementation of the system, the seed S is used 
	----          along with a pseudo-random number generator to sample the 
	----          list of indices. This is not done here, as it would result 
	----          in a specification that is very inefficiently executable. 
	----          The inefficiency is due to Maude's implementation of the 
	----          random function being based on the Mersenne Twister RNG (in
	----          which computing the random value corresponding to S requires
	----          computing the previous value for S-1). In other words, Maude's 
	----          random function was not designed to support user-supplied
	----          seeds. To resolve this issue, we generate our pseudo-random
	----          number using an arithmetic combination of the seed S and the
	----          position in the list for which the number is being generated. 
	----          We note that this approach is still faithful to the original 
	----          protocol since the seed S itself is generated pseudo-randomly
	----          (using the function random), and thus, the resulting number 
	----          is also pseudo-random. 
	----    e.g.: sampleIndexList(100, 5, 748692346) = 80 . 20 . 52 . 76 . 92
	----
    op sampleIndexList : Nat Nat Seed -> [NatList] .
    eq sampleIndexList(N, 0, S) = nilIL .
    ----eq sampleIndexList(N, s(K), S) = random(S + s(K)) rem N . sampleIndexList(N, K, S) .
	eq sampleIndexList(N, s(K), S) = (S * s(K) * s(s(K))) rem N . sampleIndexList(N, K, S) .

    ---- countCompromised(IL1, IL2): 
    ----    IL1: A list of indices (the proposers list)
    ----    IL2: A list of indices (the compromised validator list)
    ----    Result: Returns the number of indices in the first list that appear 
    ----            in the second (and hence the number of compromised validators
    ----            in the proposers list)
    ----    e.g.: countCompromised(2 . 5 . 3 . 2 . 9 . 4, 1 . 2 . 4 . 5 . 9) = 5
    ----    e.g.: countCompromised(2 . 5 . 3 . 2 . 9 . 3, 1 . 2 . 4 . 5 . 9) = 4
    ---- 
	op countCompromised : NatList NatList -> [Nat] .
	eq countCompromised(IL1, IL2) = countCompromised*(IL1, IL2, 0) .

	---- A helper (tail-recursive) function to countCompromised
	op countCompromised* : NatList NatList Nat -> [Nat] .
	eq countCompromised*((IL1 . I . IL1'), (IL2 . I . IL2'), N) = countCompromised*((IL1 . IL1'), (IL2 . I . IL2'), s(N)) .
	eq countCompromised*(IL1, IL2, N) = N [owise] .

    ---- countCompromisedTail(IL1, IL2): 
    ----    IL1: A list of indices (the proposers list)
    ----    IL2: A list of indices (the compromised validator list)
    ----    Result: Returns the size of the longest (continuous) tail of indices  
    ----            in the first list that appears in the second (and hence the 
    ----            number of last validators that are compromised in the 
    ----            proposers list)
    ----    e.g.: countCompromisedTail(2 . 5 . 3 . 2 . 9 . 4, 1 . 2 . 4 . 5 . 9) = 3
    ----    e.g.: countCompromisedTail(2 . 5 . 3 . 2 . 9 . 3, 1 . 2 . 4 . 5 . 9) = 0
    ----
	op countCompromisedTail : NatList NatList -> [Nat] .
	eq countCompromisedTail(IL1, IL2) = countCompromisedTail*(IL1, IL2, 0) .

	---- A helper (tail-recursive) function to countCompromisedTail
	op countCompromisedTail* : NatList NatList Nat -> [Nat] .
	eq countCompromisedTail*((IL1 . I), (IL2 . I . IL2'), N) = countCompromisedTail*(IL1, (IL2 . I . IL2'), s(N)) .
	eq countCompromisedTail*(IL1, IL2, N) = N [owise] .

	---- computeScoreFunction(I, IL, IL'):
	----    I:  The index of the score function to be used 
	----        0 for countCompromised
	----        1 for countCompromisedTail
	----    IL: The first list 
	----    IL: The second list 
	----    Result: Computes the score of IL and IL' based on the function index I 
    ----    e.g.: computeScoreFunction(0, 2 . 5 . 3 . 2 . 9 . 4, 1 . 2 . 4 . 5 . 9) = 5
    ----    e.g.: computeScoreFunction(1, 2 . 5 . 3 . 2 . 9 . 4, 1 . 2 . 4 . 5 . 9) = 3
    ----
	op computeScoreFunction : Nat NatList NatList -> [Nat] .
	eq computeScoreFunction(0, IL, IL') = countCompromised(IL, IL') .
	eq computeScoreFunction(1, IL, IL') = countCompromisedTail(IL, IL') .

	---- length(IL):
	----    I:  A list of nats 
	----    Result: The length of IL 
    ----
	op length : NatList -> [Nat] .
	eq length(nilIL) = 0 .
	eq length(I . IL) = s(length(IL)) .

	op toNatSet : NatList -> [NatSet] .
	eq toNatSet(nilIL) = mtIS .
	eq toNatSet(I . IL) = I , toNatSet(IL) .
endm


***( 
*** Attacker (Compromised) Validator Roles
***
*** This modules defines data structures specifying validator roles.
*** A validator role defines the behavior of a validator as a member
*** of the proposers list. A validator may be honest, in which case 
*** it behaves according to the protocol. A compromised validator may
*** assume one of three roles labeled: isolated, ctailhead and 
*** ctailtail, depending on its position in the proposers list. An 
*** isolated validator is one that does not belong to a compromised 
*** tail of the list. ctailhead and ctailtail are the validator roles 
*** for the head and the tail of the compromised tail. We give an
*** example below:
***  
*** Example 1: Assuming 3, 5, 7 and 9 are the only compromised 
***            validators, in the list of proposers 
***                       1 . 2 . 3 . 5 . 4 . 7 . 9
***            we have the following roles:
***            * 3 and 5 are isolated
***            * 7 is a ctailhead
***            * 9 is a ctailtail
***
*** Since a validator with role ctailhead will need the seeds of all
*** vaildators in the rest of the tail of the list (ctailtail validators),
*** the ctailhead role maintains this list of seeds as an argument (this
*** is another design for efficincy that is not strictly needed).
***
*** Finally, since the same validator may appear more than once in the 
*** proposers list, a validator may have more than one role. We therefore
*** index a role by the slot number for that role. For instance, in the 
*** example above, if the list was 1 . 2 . 7 . 5 . 4 . 7 . 9, validator 7
*** would have two roles (a role set): [3 : isolated] [6 : ctailhead].
)
mod ROLES is 
	protecting NATLIST .

	---- Compromised validator role positions: 
	---- constructers for isolated, ctailhead(IL) and ctailtail
	sort CPosition .
	ops isolated ctailtail : -> CPosition [ctor] .
	op  ctailhead : NatList -> CPosition [ctor] .

	---- Roles and Role Sets
	sort Role CRoleSet CRole .
	---- A 'Role' is a set of slot-indexed compromised
	---- roles 'CRoleSet'
	subsort CRoleSet < Role .
	---- A single 'CRole' is a (degenerate) instance of 'CRoleSet'
	subsort CRole < CRoleSet .

	---- A compromised role is a slot-indexed compromised role position 
	op [_:_] : Nat CPosition -> CRole [ctor].
	---- A set of compromised roles is constructed by mtCRS, for the empty
	---- set, and the associative commutative comma operator with id mtCRS
	op mtCRS : -> CRoleSet [ctor] .
	op _,_ : CRoleSet CRoleSet -> CRoleSet [ctor comm assoc id: mtCRS] .
endm


***( 
*** Validator Records
***
*** This modules defines validator records, which are data structures used 
*** to maintain details of validators needed for the proper execution of the 
*** protocol and the attacker. There are two types of validator records: 
*** (1) general validator records that maintain:
***		* The validator's (actor object) name
***		* The current-round seed
***     * The hash of the current seed 
***     * The next-round seed 
***     * The validator's profit (in Ether) 
*** (2) compromised validator records that maintain:
***		* The validator's (actor object) name
***     * The validator's role
***
*** While a general validator record exists for each validator, only 
*** compromised validators that are part of the proposers list in the
*** current round have compromised validator records as well.
)
mod VRECORD is
	protecting APMAUDE .
	protecting NATLIST .
	protecting ROLES .

	---- General validator record
	sort VRecord .
	---- A general validator record is a triple < A, H, N >, with A the 
	---- validator's name (identifier), H its hash, and N its net balance.
	op <_,_,_,_,_> : ActorName Seed Hash Seed Int -> VRecord [ctor] .

	---- General validator record list 
	sort VRecordList .
	---- A general validator record list is constructed by a single record,
	---- the empty record list nilVHL, or by the associative semi-colon
	---- operator on record lists, with nilVHL the identity element.
	subsort VRecord < VRecordList .
	op nilVHL : -> VRecordList [ctor] .
	op _;_ : VRecordList VRecordList -> VRecordList [ctor assoc id: nilVHL] .

	---- Private validator record
	sort CVRecord .
	---- A private validator record is a quadruple < A, S, S', R >, with A the 
	---- validator's name (identifier), S and S' are its current and next-round
	---- seeds respectively, and R its role.
	op <_,_> : ActorName Role -> CVRecord [ctor] .

	---- Private validator record list 
	sort CVRecordList .
	---- A private validator record list is constructed by a single record,
	---- the empty record list nilCVL, or by the associative semi-colon
	---- operator on record lists, with nilCVL the identity element.
	subsort CVRecord < CVRecordList .
	op nilCVL : -> CVRecordList [ctor] .
	op _;_ : CVRecordList CVRecordList -> CVRecordList [ctor assoc id: nilCVL] .
endm

***( 
*** Proposer Records
***
*** This modules defines proposer records maintained by the RANDAO object.
*** These are simple data structures used to record whether a proposer 
*** manageed to successfully propose a valid block and reveal its seed. 
*** A proposer record is a pair [A, B], with A the proposers name, and B
*** a boolean flag indicating whether A successfully revealed its seed. 
***
)
mod PRECORDS is
	protecting APMAUDE .

	---- Proposer record 
	sort PRecord .
	op [_,_] : ActorName Bool -> PRecord [ctor] .
	---- PRecord record list 
	sort PRecordList .
	subsort PRecord < PRecordList .
	op nilPL : -> PRecordList [ctor] .
	op _;_ : PRecordList PRecordList -> PRecordList [ctor assoc id: nilPL] .
endm

***(
*** Attack strategies
***  
*** This module defines data structures and operations for specifying
*** attack strategies for compromised validators appearing in the proposers
*** list's compromised tail (the ones with roles ctailhead and ctailtail). 
*** An attack strategy is a pair [G : S], where G is the index identifying the
*** strategy and S is its resulting seed. G instructs validators in the
*** compromised tail to either reveal or skip their turns in a round of the 
*** game. Although G is a natural number, the binary representation of the 
*** index G precisely defines the strategy (1 means reveal and 0 means do not
*** reveal). For example, the strategy indexed 6 (in binary 6 = 110) states
*** that the first validator skip (the 0 in 110) and the following 
*** two validators should reveal (the two 1's in 110). Note that the binary
*** string is read in reverse (the head of the validator list corresponds to
*** the least significant binary digit). This provides a compact representation 
*** of strategies that is easy to compute and read. Note that:
*** 1. the remainder operation G rem 2 gives the current strategy action
*** 2. the integer quotient G quo 2 returns the rest of the strategy
*** The seed S is what one would get if the stragey specified by G was applied
*** to a given initial seed (the RANDAO computed seed). An attacker may 
*** pre-compute a set of strategies to decide the best attack strategy given  
*** the current circumstances. 
***
)
mod STRATEGY is
	protecting HASH .

	---- Attack strategy 
	sort Strategy .
	---- A strategy is a pair [I : SKL], with SKL is a skip list and I its
	---- score.
	op [_:_] : Nat Seed -> Strategy .

	sort StrategySet .
	subsort Strategy < StrategySet .

	---- op mtSTS : -> StrategySet .
	op __ : StrategySet StrategySet -> StrategySet [assoc comm] .
endm


***(
*** Actor Names
***  
*** This module defines the actor names of the actor objects that could 
*** appear in a configuration. There are five actors in total:
***   v(I) : a validator with index I 
***   bc   : the blockchain actor (modeling the state of the protocol)
***   r    : the RANDAO contract actor 
***   a    : the attacker actor 
***   g   : the validator generator actor (for modeling a dynamic validator set)
*** 
*** We note that, for execution efficincy, a validator actor v(I) is not  
*** represented by its own actor object, but rather by its validator records
*** stored in other objects (bc and a).  					
)
mod OBJECTS is 
	extending APMAUDE .
    op v  : Nat -> ActorName .   --- Validators
    op bc :     -> ActorName .   --- Blockchain 
    op r  :     -> ActorName .   --- RANDAO Contract
    op a  :     -> ActorName .   --- Attacker
    op g :     -> ActorName .   --- Validator Generator
endm

***(
*** Actor attributes
***  
*** This module defines all attributes that may be part of an actor object
*** in the specification. An attribute is a key-value pair that records
*** important information about the state of an actor. Note that an 
*** attribute may appear in more than one actor type.
***   	
*** Below, we list the attributes of each actor object:
***
*** Blockchain:
***		<name: bc |					---- The Blockchain Object
***			seed:           S,  	---- seed of previous game round
***			vpending:       VHL,    ---- list of records of pending validators 
***			vpending-size:  N,      ---- their count
***			vapproved:          VHL',   ---- list of records of approved validators  
***			vapproved-size:     N'      ---- their count
***		> .
***
*** RANDAO Contract:
***		<name: r |					---- the RANDAO Contract
***			status:         U,      ---- status can be 'ready' or 'processing' 
***			balance:        N,      ---- current contract balance 
***			success-rounds: J,      ---- number of successful rounds
***			precords:      PL, 	---- proposers participating in the current game round
***			prop-size:      M,      ---- their count (in the steady state, this must be equal to #CYCLE-LENGTH)
***			prop-ilist: 	IL, 	---- their indices,       
***			pnext:          I       ---- next validator (time slot) to process
***		> .
***
*** Attacker:
*** 	<name: a |					---- the Attacker Object
***			vcomp:			CVL,	---- private validator records
***			vcomp-ilist:	IL,		---- a list of the compromised validator indices
***			vcomp-size:		N,      ---- the size of IL
***			strategy:		G		---- the attacker's strategy (for tails controlled by the attacker)
***		> .	
***
***	Validator Generator: 
***		<name: g | 				---- the validator generator 
***			vcount: N, 				---- the index of the next validator to be generated 
***			contract: RID,			---- the name of the RANDAO contract 
***			next-seed: S,			---- the seed of the next validator to be generated
***			next-comp: B > .		---- a Boolean indicating whether the next validator is compromised or not 
***
)
mod ATTRIBUTES is
    protecting VRECORD .
    protecting PRECORDS .
    protecting NATLIST .
    protecting STRATEGY .

    --- states of an actor
    sort Status .
    ops processing ready : -> Status . 

    --- Attributes (as explained above)
    op status:_         : Status		-> Attribute [format (m o d)] .  
    op balance:_        : Nat			-> Attribute [format (m o d)] .  
    op seed:_           : Seed			-> Attribute [format (m o d)] .
    op vapproved:_      : VRecordList 	-> Attribute [format (m o d)] .
    op vapproved-size:_ : Nat			-> Attribute [format (m o d)] .
    op vpending:_       : VRecordList	-> Attribute [format (m o d)] .
    op vpending-size:_  : Nat			-> Attribute [format (m o d)] .
    op precords:_       : PRecordList	-> Attribute [format (m o d)] .
    op prop-ilist:_     : NatList		-> Attribute [format (m o d)] .
    op prop-size:_      : Nat			-> Attribute [format (m o d)] .
    op pnext:_          : Nat 			-> Attribute [format (m o d)] .
    op success-rounds:_ : Nat			-> Attribute [format (m o d)] .
    op contract:_       : ActorName 	-> Attribute [format (m o d)] .
    op next-seed:_      : Seed 			-> Attribute [format (m o d)] .
    op vcomp:_ 			: CVRecordList	-> Attribute [format (m o d)] .
    op vcomp-ilist:_ 	: NatList 		-> Attribute [format (m o d)] .
    op vcomp-size:_     : Nat			-> Attribute [format (m o d)] .
    op strategy:_ 		: Nat 			-> Attribute [format (m o d)] .
    op vcount:_ 		: Nat 			-> Attribute [format (m o d)] .
    op next-comp:_ 		: Bool 			-> Attribute [format (m o d)] .
endm


***(
*** Message Content
***
*** This module defines message contents (payload) that could potentially be 
*** used in messages exchanged between actors of the system. Recall that a
*** message has the form (A <- C), where A is the target actor and C is the 
*** content of the message, which we define here. 
***    
)
---- Message contents
mod MESSAGES is
    protecting VRECORD .
    protecting PRECORDS .
   	extending APMAUDE .

	---- Message Contents:

	---- reveal(A, S, H): A reveal by actor A of the seed S while  
	---- committing to the next seed using H 
	op  reveal 		: ActorName Seed Hash 	-> Content .

	---- nextSlot(K): schedule advancing the process to the next slot
	---- (used in self-addressed messages) 
	op  nextSlot 	: Nat  					-> Content . 

	---- nextRound(): schedule advancing the process to the next round 
	---- (used in self-addressed messages) 
	op  nextRound 	:   					-> Content . 
 
	---- doReveal(X, K): schedule a possible reveal action at slot K 
	---- 				where X is 0 for an honest validator and 1 
	---- 				for a compromised validator
	---- (used in self-addressed messages) 
	op  doReveal	: Nat Nat					-> Content . 

	--- spawn() : schedule arrival of the next validator to the system 
	---- (used in self-addressed messages when dynamic validators are 
	---- assumed) 
	op  spawn		:						-> Content . 
endm

***(
*** Actor Configuraiton
***
*** This module defines additional configuration components (in addition
*** to actors, messages and the scheduler which were defined in a previous
*** module).  
***    
)
---- 
mod CONFIG is
	protecting ATTRIBUTES .
	protecting OBJECTS .
	protecting MESSAGES .
	protecting NATLIST .

    --- Additional configuration fields

    ---- limit(B, F): A control device that allows us to specify the length
    ---- of a simulation run (the macro step captured by 'tick')
    op limit : Bool Float   -> Config [format (nb! o)] .

    ---- round(F): Maintains the current RANDAO game round 
    ---- (not strictly needed but is there for convenience)
    op round : Float   -> Config [format (nb! o)] .
endm


***(
*** RANDAO Actions
***
*** This module defines how the RANDAO actor behaves. Behavior is 
*** captured by rewrite rules specifying transitions in the system.
*** There are three transitions:
*** 1. RAdvanceSlot: which advances the process to the next slot
*** 2. RAdvanceRound: which advances the process to the next round
*** 3. RProcessReveal: which processes a reveal message from a proposer
***    
*** The module also defines other operations needed for the 
*** specification of these transitions.
***
)
mod RANDAO-BEHAVIOR is
	protecting CONFIG .
	protecting PARAMS .

	vars S S' S'' RS 				: Seed .
	vars AS AS' AS'' 				: AttributeSet . 
	vars T TG TS TS' TR TR' D R F 	: Float .
	vars SL SL' 					: ScheduleList . 
	vars ST ST' 					: Strategy .
	vars SSTS STS STS' 				: StrategySet .
	vars CID VID RID OID AID BID 	: ActorName .
  	vars H H' 						: Hash .
	vars I J K L M M' N N' G G'     : Nat .
	vars VHL VHL'                   : VRecordList .
	vars CVL CVL'                   : CVRecordList .
	vars CL                         : PRecordList .
	vars B B' T?                    : Bool .
	vars IL IL' IL1 IL1' IL2 IL2'   : NatList .
	vars X                          : Int .
	vars RO                         : Role .
	vars CRS                        : CRoleSet . 
	vars SDL                        : NatList .
	vars IS                         : NatSet .

	****************************************
	**** Some Operations Needed by the Rules
	**************************************** 

	---- i*(IL, IL'): 
	----	IL: A nat list (list of proposer indices)
	----	IL': A nat list (list of attacker indices)
	---- 	Result: A list of private validator records corresponding for 
	----    		attacker validators appearing in IL 
	----
	---- e.g. makeCVL*( 0 . 1 . 2 . 3,  0 . 2 . 4) may rewrite to
	---- 		< v(0), 2156527062, mtCRS > ; 
	---- 		< v(2), 3212733452, mtCRS >
	---- 
	op makeCVL : NatList NatList -> [CVRecordList] .
	eq makeCVL(IL, IL') = makeCVL*(toNatSet(IL), IL') .

	op makeCVL* : NatSet NatList -> [CVRecordList] .
	eq makeCVL*(mtIS, IL') = nilCVL .
	eq makeCVL*((I , IS), (IL1 . I . IL1')) 
		=  makeCVL*(IS, (IL1 . I . IL1')) ; < v(I), mtCRS > .
    eq makeCVL*((I , IS), IL')
		=  makeCVL*(IS, IL') [owise] .

	---- updateRewards(VHL, CL) 
	----    VHL: list of validator records 
	----    CL: list of proposer records 
	----    Result: The validator records list VHL where each successful reveal 
	----            is rewarded by increasing the corresponding validator balance.
	----            Whether a reveal was successful is given by the appropriate 
	----            record in CL.
	---- Note 1: Rewarding means adding 2 Ether to the validator record balance
	---- Note 2: This is so far unused (but could be built on in a future version)
	----
	---- e.g. updateRewards(< v(0) , H , 10 >, [v(0) , true])  = < v(0) , H , 12 >
	---- e.g. updateRewards(< v(0) , H , 10 >, [v(0) , false]) = < v(0) , H , 10 >
	----
    op updateRewards : VRecordList PRecordList -> [VRecordList] .
    eq updateRewards(VHL, nilPL) 
    	= VHL . 
    eq updateRewards((VHL ; < v(I), S, H, S', X > ; VHL'), [ v(I) , B' ] ; CL) 
    	= updateRewards((VHL ; < v(I), S, H, S', (if B' then X + 2 else X fi) > ; VHL'), CL) .

	---- makePropRecords(IL) 
	----    IL: list of proposer indices 
	----    Result: The list of proposer records corresponding to IL, where 
	----            the reveal status is initialized to false.
	----
	---- e.g. makePropRecords(1 . 0)
	----         = [v(1) , false] ; [v(0), false]
	----
    op makePropRecords : NatList -> [PRecordList] .
    eq makePropRecords(nilIL) = nilPL . 
    eq makePropRecords(I . IL) = [ v(I) , false ] ; makePropRecords(IL) .

    ---- setNewCVRoles(CVL, IL)
    ----	CVL: list of (private) validator records 
    ----	IL: list of proposer indices 
    ----	Result: The list of (private) validator records CVL in which 
    ----			the roles of the validators appearing in IL are appropriately
    ----            set according to the validator type and position in IL 
    ----
    ---- e.g. Assuming CYCLE-LENGTH = 2, we have 
    ----	setNewCVRoles(< v(0), S0, S0', honest > ; < v(1) , S1, S1' , mtCRS >, (1 . 0))
    ----		  = < v(0), S0, S0', honest > ; <v(1) , S1, S1' , [1 : isolated] >
	----
    ---- e.g. Assuming CYCLE-LENGTH = 4, we have 
    ----	setNewCVRoles(< v(0), S0, S0', honest > ; < v(1) , S1, S1' , mtCRS >, (1 . 0 . 1 . 1))
    ----		  = < v(0), S0, S0', honest > ; 
    ----            < v(1), S1, S1', [1 : isolated], [3 : ctailhead(S1 . S1)],[4 : ctailtail] >
    ----
    op setNewCVRoles : CVRecordList NatList VRecordList -> [CVRecordList] .
    eq setNewCVRoles(CVL, IL, VHL) = setNewCVRoles*(CVL, IL, VHL, #CYCLE-LENGTH, true, nilIL) .

    ---- setNewCVRoles*(CVL, IL, N, B, SDL)
    ----	CVL: list of (private) validator records 
    ----	IL: list of proposer indices 
    ----	N: A natural number (the remaining records in the proposers list) 
    ----	B: A Boolean indicating whether an honest validator has been seen so far
    ---- 	SDL: The list of seeds of the compromised tail of IL collected so far     
    ----    Result: The list of (private) validator records CVL in which 
    ----			the roles of the validators appearing in IL are appropriately
    ----            set according to the validator type and position in IL  
    ---- This is a helper function to setNewCVRoles(CVL, IL)
    ----
    op setNewCVRoles* : CVRecordList NatList VRecordList Nat Bool NatList -> [CVRecordList] .
    eq setNewCVRoles*(CVL, nilIL, VHL, N, B, SDL) 
    	=  CVL . 
    eq setNewCVRoles*((CVL ; < v(I) , CRS > ; CVL'), (IL . I), VHL, s(N), false, SDL) 
    	= setNewCVRoles*((CVL ; < v(I) , (CRS , [s(N) : isolated]) > ; CVL'), IL, VHL, N, false, SDL) .
   ceq setNewCVRoles*((CVL ; < v(I) , CRS > ; CVL'), (IL . I), (VHL ; < v(I), S, H, S', X > ; VHL'),  s(N), true, SDL) 
    	= if B then 
    		setNewCVRoles*((CVL ; < v(I) , (CRS , [s(N) : ctailtail]) > ; CVL'), IL, (VHL ; < v(I), S, H, S', X > ; VHL'),  N, true, (S . SDL)) 
    	  else
    		setNewCVRoles*((CVL ; < v(I) , (CRS , [s(N) : ctailhead(S . SDL)]) > ; CVL'), IL, (VHL ; < v(I), S, H, S', X > ; VHL'),  N, true, (S . SDL)) 
    	  fi
    	if B := compEnd?((CVL ; < v(I) , CRS > ; CVL'), IL) .
    eq setNewCVRoles*(CVL, (IL . I), VHL, s(N), T?, SDL) = setNewCVRoles*(CVL, IL, VHL, N, false, SDL) [owise] .

    ---- compEnd?(CVL, IL)
    ----	CVL: list of (private) validator records 
    ----    IL : list of proposer indices
    ----    Result: A Boolean indicating whether the end of IL is compromised
    ---- This is a helper function to setNewCVRoles(CVL, IL)
    ---- 
    op compEnd? : CVRecordList NatList -> [Bool] .
    eq compEnd?((CVL ; < v(I) , CRS > ; CVL'), (IL . I)) = true .
    eq compEnd?(CVL, IL) = false [owise] .

    ---- createDoReveals(F, A, N, IL, IL')
    ----	F: the global time value 
    ---- 	A: the RANDAO contract actor name (not really used in this version)
    ----    N : a counter representing the number of messages created so far 
    ----    IL: list of validator indices (target validators)
    ----    IL': list of compromised validator indices
    ----    Result: A list of scheduled doReveal messages targeted at validators  
    ---- 			in IL with base time value TG 
    ---- 
    ---- e.g. createDoReveals(0.0, r, 3, (2 . 5 . 7), (2 . 7)) may rewrite to:
    ---- 			[0.0260136714847790, v(2) <- doReveal(1, 1), 0] ; 
    ----            [1.0773220517922477, v(5) <- doReveal(0, 2), 0] ; 
    ----            [2.0658048222786292, v(7) <- doReveal(1, 3), 0]
    ----      
    op createDoReveals : Float ActorName Nat NatList NatList -> [ScheduleList] .
    eq createDoReveals(TG, RID, N, nilIL, IL') = nil .
    eq createDoReveals(TG, RID, N, I . IL, (IL1 . I . IL1')) = [TG + float(N) + #TRANSMISSION-DELAY, (v(I) <- doReveal(1, s(N))), #MSG-DROP-PROB] ; createDoReveals(TG, RID, s(N), IL, (IL1 . I . IL1')) .
    eq createDoReveals(TG, RID, N, I . IL, IL') = [TG + float(N) + #TRANSMISSION-DELAY, (v(I) <- doReveal(0, s(N))), #MSG-DROP-PROB] ; createDoReveals(TG, RID, s(N), IL, IL') [owise] .

    op allCompromised? : NatList NatList -> [Bool] .
    eq allCompromised?(nilIL, IL) = true .
    eq allCompromised?(I . IL, IL1 . I . IL2) 
    	= allCompromised?(IL, IL1 . I . IL2) .
    eq allCompromised?(IL, IL') = false [owise] .
	****************************************
	**** The Rules
	**************************************** 

	---- RAdvanceSlot: Advance the process to the next slot
	---- This rule processes a message of the form nextSlot(L), which initiates
	---- the process of advancing the state of the protocol to the next slot. 
	---- Assuming K is the next slot number to be processed as recorded in the
	---- state of the RANDAO contract object, there are three cases:
	---- Case 1: L > #CYCLE-LENGTH, which means that the protocol has already
	----	processed the end of the #CYCLE-LENGTH proposers for the current 
	----    round, and progressing to the next slot would require advancing the
	----    the current round of the game first. The RANDAO contract object 
	---- 	changes its status to 'processing', samples a new proposers list
	---- 	using its stored computed seed, and resets the slot count back to 1. 
	---- 	It also emits a zero-delay 'nextRound' message to continue its 
	----    preparation for the following round of the game. 
	---- Case 2: L == K, which means that slot number was already advanced by
	---- 	successfully processing a reveal. In this case, the state is not
	---- 	changed and a 'nextSlot' message is scheduled as normal.
	---- Case 3: L > K, which means the slot number was not advanced before
	----	and thus, either a reveal was attempted but failed or that a reveal
	----    was never received. In both cases, the RANDAO object records that 
	----	as a failure in the proposers record list and advances the slot 
	----	number. It also schedules a 'nextSlot' message for the next slot. 
	----
 rl [RAdvanceSlot] :
 	limit(true, D)
 	<name: BID |		
			seed:           S, 
			vapproved-size:     N,
			vpending-size:	N',
			AS >
 	<name: RID |		
			status:	ready, 
			precords:	([ VID , B ] ; CL),
			prop-ilist: IL,       
			pnext:	K,
			AS' >
    { TG | SL }
    (RID <- nextSlot(L))
    => limit(TG <= #SIM-TIME-LIMIT * D, D)
    	<name: BID |		
				seed:           S, 
				vapproved-size:     N,
				vpending-size:	N',
				AS >
    	if L > #CYCLE-LENGTH then
    		---- End of game round: prepare to advance to the next round 
 			<name: RID |		
					status:	processing, 
					precords:	([ VID , B ] ; CL),       
					prop-ilist: sampleIndexList(N + N', #CYCLE-LENGTH, S),       
					pnext:	1,
					AS' >
    		{ TG | SL }
    		(RID <- nextRound)
    	else 
    		if L == K then 
    			---- Slot was already advanced by a valid reveal -- so no changes 
 				<name: RID |		
						status:	ready, 
						precords:	([ VID , B ] ; CL),       
						prop-ilist: IL,       
						pnext:	K,
						AS' >
			else
				---- Slot was not advanced -- advance it and record failure of a reveal
 				<name: RID |		
						status:	ready, 
						precords:	(CL ; [ VID , false ]),       
						prop-ilist: IL,       
						pnext:	s(K),
						AS' >
			fi 
			mytick(insert({ TG | SL }, [floor(TG) + 1.0, (RID <- nextSlot(s(L))), 0])) 
		fi
    	[print TG ": RAdvanceSlot: from " K " to " L] .

    ---- RAdvanceRound: Advance the process to the next round 
    ---- This rule processes a 'nextRound' message. Several steps are taken in this 
    ---- transition:
    ---- 1. The (general) validator records VHL are updated to reward those who have 
    ----    successfully reveled their seeds in the last round (with updateRewards).
    ---- 2. The pending validators list VHL' is incorporated into the approved list
    ----    in preparation for their participation in the next round and the list 
    ----    sizes are updated accordingly.
    ---- 3. Given the freshly sampled list of proposer indices IL, the list (private)
    ----    validator records for the compromised validators are updated with 
    ----    potentially new attacker roles (with setNewCVRoles).  
    ---- 4. Given the freshly sampled list of proposer indices IL, a new proposers
    ----    list is created and initialized (with makePropRecords) 
    ---- 5. A new list of 'doReveal' messages is created and inserted into the 
    ----    scheduler, along with a 'nextSlot' message to resume advacning rounds.
    ----
  rl [RAdvanceRound] :
 	limit(true, D)
 	round(R)
 	<name: BID |		
			vapproved:          VHL,
			vapproved-size:		N,
			vpending:		VHL',
			vpending-size:	N', 
			AS >
	<name: a   |
			vcomp: 			CVL,
			vcomp-ilist:	IL',
			AS' >
 	<name: RID |		
			status:			processing, 
			balance: 		J,
			success-rounds: I, 
			precords:      CL,
			prop-ilist:		IL, 
			prop-size:     	M,
			pnext:          K,
			AS'' >
    { TG | SL }
    (RID <- nextRound)
    =>  round(R + 1.0)
	 	<name: BID |		
				vapproved:          (updateRewards(VHL, CL) ; VHL'), 
				vapproved-size:		(N + N'),
				vpending:		nilVHL,
				vpending-size:	0, 
				AS >
		<name: a   |
				vcomp: 			setNewCVRoles(makeCVL(IL, IL'), IL, (VHL ; VHL')),
				vcomp-ilist:	IL',
				AS' >
 		<name: RID |		
				status:			ready, 
				balance: 		J,
				success-rounds: s(I), 
				precords:      makePropRecords(IL),
				prop-ilist:		IL, 
				prop-size:     	M,
				pnext:          1,
				AS'' >
		if allCompromised?(IL,  IL') then 
    		limit(false, D)
    		{ TG | SL }
    	else
    		limit(TG <= #SIM-TIME-LIMIT * D, D)
    		mytick(insertList(insert({ TG | SL }, [floor(TG) + 1.0, (RID <- nextSlot(2)), 0]), createDoReveals(TG, RID, 0, IL, IL'))) 
    	fi
    	[print TG ": RAdvanceRound with new committee " IL] .


    ---- RProcessReveal: Process an incoming reveal message 
    ---- This rule processes a 'reveal' message sent by a proposer. There are
    ---- two cases:
    ---- 1. The reveal is successful (the commit check is successful), in which
    ----    case (1) the new seed is computed (using combineSeeds which XORs the 
    ----    currently stored seed with the revealed seed), (2) the fact that the 
    ----    reveal was successful is recorded in the proposers record, and (3)
    ----    the slot counter is incremented. 
    ---- 2. The reveal is not successful, in which case the failure is recorded
    ----    int the proposers record list.
    ---- In both cases, no new message is scheduled.
    ----
 rl [RProcessReveal] :
 	limit(true, D)
 	<name: BID |		
			seed:	RS,  
			vapproved:	(VHL ; < VID, S, H, S', X > ; VHL') ,   
			AS >
 	<name: RID |		
			status:	ready, 
			precords:	([ VID , B ] ; CL),       
			pnext:	J,
			AS' >
    { TG | SL }
    (RID <- reveal(VID, S'', H'))
    => limit(TG <= #SIM-TIME-LIMIT * D, D)
    	if (H == h(S'')) then 
    		---- The reveal is successful
		 	<name: BID |		
					seed:	combineSeeds(RS, S),  
					vapproved:	(VHL ; < VID, S, H', S', X > ; VHL') ,   
					AS >
 			<name: RID |		
					status:	ready, 
					precords:	(CL ; [ VID , true ]),       
					pnext:	s(J),
					AS' >
		else
    		---- The reveal failed
		 	<name: BID |		
					seed:	RS,  
					vapproved:	(VHL ; < VID, S, H, S', X > ; VHL') ,   
					AS >
 			<name: RID |		
					status:	ready, 
					precords:	(CL ; [ VID , false ]),       
					pnext:	J,
					AS' >
		fi 
    	mytick({ TG | SL }) 
    	[print TG ": RProcessReveal received from " VID] .
endm
 
***(
*** Validator Actions
***
*** This module defines how the validators (both honest and compromised) behave. 
*** There are essentially two validator actions, which we specify here using a 
*** total of 5 rules to maintain clarity of presentation (2 rules would 
*** technically be sufficient, but would result in structurally complicated rules).
*** 1. Revealing a seed: specified by 
***		- VHonestReveal: for honest validators
***     - VCompReveal1: for compromised validators with role 'isolated'
*** 	- VCompReveal2: for compromised validators with role 'ctailtail'
*** 	- VCompReveal3: for compromised validators with role 'ctailhead'
*** 2. Arriving to the system: specified by 
***		- VArrive
***
)
mod VALIDATOR-BEHAVIOR is
	protecting CONFIG .
	protecting PARAMS .

	vars S S' RS PS : Seed .
	vars AS AS' AS'' : AttributeSet . 
	vars T TG TS TS' TR TR' D R F : Float .
	vars SL SL' : ScheduleList . 
	vars CID VID RID OID AID BID VGID : ActorName .
  	vars H : Hash .
	vars I J K L M M' N N' G G' C C' : Nat .
	vars VHL VHL' : VRecordList .
	vars CVL CVL' : CVRecordList .
	vars CL : PRecordList .
	vars B : Bool .
	vars IL IL' IL1 IL1' : NatList .
	vars X : Int .
	vars RO : Role .
	vars CRS : CRoleSet . 
	vars ST ST' : Strategy .
	vars SSTS STS STS' : StrategySet .
	vars CP : CPosition .
	vars SDL : NatList .

	****************************************
	**** Some Operations Needed by the Rules
	**************************************** 

	---- (K, RS, SDL) => K: current tree height, RS: current seed, SDL: remaining seed list 

	op createStratSet : Nat Seed NatList -> [StrategySet] .
	--- eq createStratSet(0, RS, S) = [0 : RS] .
	eq createStratSet(s(K), RS, S) = [0 : RS] [1 : combineSeeds(RS, S)] .

	ceq createStratSet(s(s(K)), RS, (SDL . S))
		= STS augment1(STS, S, s(K))
		if STS := createStratSet(s(K), RS, SDL) .

	op augment1 : StrategySet Seed Nat -> [StrategySet] .
	--- eq augment1(mtSTS) = [1 : RS] .
	eq augment1([G : RS], S, K) 	= [2 ^ K + G : combineSeeds(RS, S)] .
	eq augment1([G : RS] STS, S, K) = [2 ^ K + G : combineSeeds(RS, S)] augment1(STS, S, K) .

	 op computeScore : Seed Nat Nat NatList -> [Nat] .
	 eq computeScore(S, N, M, IL) 
	 	= computeScoreFunction(
					#SCORE-FUNCTION, 
					sampleIndexList(N, M, S),
					IL) .

	op findMaxScoreStrat : StrategySet Nat Nat NatList -> [Nat] .
	eq findMaxScoreStrat([G : S], N, M, IL) =  G .
	eq findMaxScoreStrat([G : S] STS, N, M, IL) 
	  = findMaxScoreStrat*(STS, G, computeScore(S, N, M, IL), N, M, IL) .


	op findMaxScoreStrat* : StrategySet Nat Nat Nat Nat NatList -> [Nat] .
	eq findMaxScoreStrat*([G : S], G', C', N, M, IL) 
		= if computeScore(S, N, M, IL) > C' then G else G' fi .
	ceq findMaxScoreStrat*([G : S] STS, G', C', N, M, IL) 
		= if C > C' then 
			findMaxScoreStrat*(STS, G, C, N, M, IL)
		  else 
			findMaxScoreStrat*(STS, G', C', N, M, IL)
		  fi 
		if C := computeScore(S, N, M, IL) .



	****************************************
	**** The Rules 
	**************************************** 

	---- VHonestReveal: An honest validator revealing the seed and making a commit 
	----
	---- This rule models the behavior expected from an honest validator. The validator 
	---- consumes the doReveal message and schedules a reveal message back to the RANDAO
	---- actor object having its name, the revealed seed, and the hash of the next-round
	---- seed. In preparation for future rounds, the validator updates its state and 
	---- generates a new seed to be used later on.
	----  
  rl [VHonestReveal] : 
    limit(true, D)
 	<name: BID |		
			vapproved:	(VHL ; < VID, S, H, S', X > ; VHL') ,   
			AS' >    	
    { TG | SL }
    (VID <- doReveal(0, K))  --- 0 means honest 
    => limit(TG <= #SIM-TIME-LIMIT * D, D)
 		<name: BID |		
				vapproved:	(VHL ; < VID, S', H, sampleUniWithInt(#MAX-SEED-VALUE), X > ; VHL') ,   
				AS' >    	
			mytick(insert( { TG | SL }, [ TG + #TRANSMISSION-DELAY, (r <- reveal(VID, S, h(S'))) , #MSG-DROP-PROB] ))
	[print TG ": VReveal by " VID] .

	---- VCompReveal1: A compromised validator with role "isolated" possibly revealing a seed
	----
	---- This (conditional) rule models the behavior of a compromised validator with role 
	---- 'isolated' (a validator that deos not belong to the compromised tail of the proposers 
	---- list. The validator consumes the doReveal message and computes the score of
	---- revealing the seed using computeScoreFunction. The score is compared with the 
	---- #MIN-ATTACK-SCORE, the minimum score value deemed acceptable by the attacker.
	---- If the score is below the minimum acceptable, the validator remains silent (does
	---- not schedule a reveal message) and the state remains unchanged. Otherwise, the 
	---- validator schedules a reveal message back to the RANDAO actor object having its name
	---- the revealed seed, and the hash of the next-round seed. Additionally, the validator  
	---- updates its state and generates a new seed to be used later on.
	----
	---- Recall that the score is determined by the score function the attacker is trying to
	---- optimize for (maximizing the number of the compromised validators or maximizing the
	---- the number of validators in the compromised tail).
 crl [VCompReveal1] : 
    limit(true, D)
 	<name: BID |		
			seed:	RS,  
			vapproved-size: N,
			vapproved:	(VHL ; < VID, S, H, S', X > ; VHL') ,   
			AS >
	<name: AID |
			vcomp:	(CVL ; < VID , ([ K : isolated], CRS) > ; CVL'),  
			vcomp-ilist: IL, 
			AS' >    
	{ TG | SL }
    (VID <- doReveal(1, K))
    => limit(TG <= #SIM-TIME-LIMIT * D, D)
		if B then 
 		<name: BID |		
				seed:	RS,  
				vapproved-size: N,
				vapproved:	(VHL ; < VID, S', H, sampleUniWithInt(#MAX-SEED-VALUE), X > ; VHL') ,   
				AS >
		<name: AID |
				vcomp:	(CVL ; < VID , ([ K : isolated], CRS) > ; CVL'),  
				vcomp-ilist: IL, 
				AS' >  
			mytick(insert( { TG | SL }, [ TG + #TRANSMISSION-DELAY, (r <- reveal(VID, S, h(S'))) , #MSG-DROP-PROB] ))
 		else
 		<name: BID |		
				seed:	RS,  
				vapproved-size: N,
				vapproved:	(VHL ; < VID, S, H, S', X > ; VHL') ,   
				AS >
		<name: AID |
				vcomp:	(CVL ; < VID , ([ K : isolated], CRS) > ; CVL'),  
				vcomp-ilist: IL, 
				AS' >  
			mytick({ TG | SL })
	    fi
		if B := computeScore(combineSeeds(RS, S), N, #CYCLE-LENGTH, IL) >= computeScore(RS, N, #CYCLE-LENGTH, IL) ---- #MIN-ATTACK-SCORE
		[print TG ": VCompReveal1 for slot " K " by " VID " => " B] .

	---- VCompReveal2: A compromised validator with role "ctailhead" possibly revealing a seed
	----
	---- This rule models the behavior of a compromised validator with role 'ctailhead' (a 
	---- compromised validator that is at the head of the compromised tail. The validator  
	---- consumes the doReveal message and then performs the following steps:
	----	1. It enumerates all possible attack strategies relevant to its position in the 
	----	   proposers list (enumStrategies) 
	----	2. It then computes the scores of all the enumerated strategies given the current
	----	   RANDAO seed and the seeds of all ctailtail validators (computeAllScores) 
	----	3. Finally, it finds the strategy with the maximum score (B . SKL') and updates the  
	----	   state to record that strategy (findMaxScoreStrat)
	---- The validator now applies this strategy by checking B. If B is true, the validator 
	---- reveals. Otherwise, if B is false, the validator remains silent. Other updates are 
	---- similar to the above rules. 
	----
 crl [VCompReveal2] : 
    limit(true, D)
 	<name: BID |		
			seed:	RS,  
			vapproved-size: N,
			vapproved:	(VHL ; < VID, S, H, S', X >  ; VHL') ,   
			AS >    
	<name: AID |
			vcomp:	(CVL ; < VID , ([ K : ctailhead(SDL)], CRS) > ; CVL'),   
			strategy: G,
			vcomp-ilist: IL, 
			AS' >    
	{ TG | SL }
    (VID <- doReveal(1, K))
    => limit(TG <= #SIM-TIME-LIMIT * D, D)
		if B then 
 			<name: BID |		
				seed:	RS,  
				vapproved-size: N,
				vapproved:	(VHL ; < VID, S', H, sampleUniWithInt(#MAX-SEED-VALUE), X >  ; VHL') ,   
				AS >
			<name: AID |
				vcomp:	(CVL ; < VID , ([ K : ctailhead(SDL)], CRS) > ; CVL'),  
				strategy: (G' quo 2),
				vcomp-ilist: IL, 
				AS' >  
			mytick(insert( { TG | SL }, [ TG + #TRANSMISSION-DELAY, (r <- reveal(VID, S, h(S'))) , #MSG-DROP-PROB] ))
 		else
 			<name: BID |		
				seed:	RS,  
				vapproved-size: N,
				vapproved:	(VHL ; < VID, S, H, S', X >  ; VHL') ,   
				AS >
			<name: AID |
				vcomp:	(CVL ; < VID , ([ K : ctailhead(SDL)], CRS) > ; CVL'),  
				strategy: (G' quo 2),
				vcomp-ilist: IL, 
				AS' >  
			mytick({ TG | SL })
	    fi
	if STS      := createStratSet(s(#CYCLE-LENGTH - K), RS, SDL)
	/\ G'       := findMaxScoreStrat(STS, N, #CYCLE-LENGTH, IL)
	/\ B := (G' rem 2) == 1
	[print TG ": VCompReveal2 for slot " K " by " VID " with strategy " B " . " G'] .	
	    	
	---- VCompReveal3: A compromised validator with role "ctailtail" possibly revealing a seed
	----
	---- This rule models the behavior of a compromised validator with role 'ctailtail' (a 
	---- compromised validator that belongs to the compromised tail but is not the head of 
	---- this tail). The validator consumes the doReveal message and then checks whether 
	---- it should reveal or not according to the precomputed strategy of the attacker. If
	---- B in the strategy (B . SKL) is true, the validator reveals (schedules a reveal messsage
	---- as described above). Otherwise, if B is false, the validator remains silent. Other 
	---- updates to the state are similar to the above rules. 
 crl [VCompReveal3] : 
    limit(true, D)
 	<name: BID |		
			seed:	RS,  
			vapproved-size: N,
			vapproved:	(VHL ; < VID, S, H, S', X >  ; VHL') ,   
			AS >    
	<name: AID |
			vcomp:	(CVL ; < VID , ([ K : ctailtail], CRS) > ; CVL'),   
			strategy: G,
			vcomp-ilist: IL, 
			AS' >    
	{ TG | SL }
    (VID <- doReveal(1, K))
    => limit(TG <= #SIM-TIME-LIMIT * D, D)
		if B then 
 			<name: BID |		
				seed:	RS,  
				vapproved-size: N,
				vapproved:	(VHL ; < VID, S', H, sampleUniWithInt(#MAX-SEED-VALUE), X >  ; VHL') ,   
				AS >
			<name: AID |
				vcomp:	(CVL ; < VID , ([ K : ctailtail], CRS) > ; CVL'),  
				strategy: (G quo 2),
				vcomp-ilist: IL, 
				AS' >  
			mytick(insert( { TG | SL }, [ TG + #TRANSMISSION-DELAY, (r <- reveal(VID, S, h(S'))) , #MSG-DROP-PROB] ))
 		else
 			<name: BID |		
				seed:	RS,  
				vapproved-size: N,
				vapproved:	(VHL ; < VID, S, H, S', X >  ; VHL') ,   
				AS >
			<name: AID |
				vcomp:	(CVL ; < VID , ([ K : ctailtail], CRS) > ; CVL'),  
				strategy: (G quo 2),
				vcomp-ilist: IL, 
				AS' >  
			mytick({ TG | SL })
	    fi
	    if B := (G rem 2) == 1
		[print TG ": VCompReveal3 for slot " K " by " VID " => " B] .	    	



	---- VArrive: A new validator requesting to join the system 
	----
	---- This rule models the arrival of a fresh validator into the system. 
	---- Upon receiving the 'spawn' message, the validator generator creates
	---- new validator records and adds them to the pending list of validators,
	---- and the size of pending validators is incremented. If the validator is 
	---- compromised (controlled by the attacker), the list of (private) 
	---- validator records is also augmented, and the list of compromised 
	---- validator indices and its size are updated accordingly. In any case, 
	---- The generator updates its state by preparing the index, seed and the
	---- compromised state of the next freah validator to be generated, and
	---- schedules another 'spawn' message delayed by the validator arrival
	---- delay.
	----  
  rl [VArrive] : 
    limit(true, D)
	<name: BID |												
		vpending:       VHL, 
		vpending-size:  M,
		AS >
    <name: AID  | 
		vcomp-ilist: IL, 
    	vcomp-size: M', 
    	AS' >  								
    <name: VGID |
	    	vcount: N, 
	    	contract: RID,
	    	next-seed: S,
		   	next-comp: B,
	    	AS'' >
    { TG | SL }
    (g <- spawn)
    => limit(TG <= #SIM-TIME-LIMIT * D, D)
		<name: BID |												
			vpending:       (VHL ; < v(N), S, h(S), sampleUniWithInt(#MAX-SEED-VALUE), (- #DEPOSIT-SIZE) >), 
			vpending-size:  s(M),
			AS >
		if B then
	    	<name: AID  | 
				vcomp-ilist: (IL . N), 
	    		vcomp-size: s(M'), 
	    		AS' >  								
	    else
	    	<name: AID  | 
				vcomp-ilist: IL, 
	    		vcomp-size: M', 
	    		AS' >  			
	    fi 					
    	<name: VGID |
		    	vcount: s(N), 
		    	contract: RID,
		    	next-seed: sampleUniWithInt(#MAX-SEED-VALUE),
		    	next-comp: sampleBerWithP(#ATTACK-PROB),
	    		AS'' >
		mytick(insert( { TG | SL }, 
			[ TG + #VARRIVAL-DELAY, (VGID <- spawn) , 0]))
	[print TG ": VArrive: s(" N ")"] .
endm

mod INIT-STATE is
	protecting VALIDATOR-BEHAVIOR .
	protecting RANDAO-BEHAVIOR .

	vars I J M N K : Nat .
	vars S S' : Seed .
	vars RID VID AID : ActorName .
	vars VHL VHL' : VRecordList .
	vars CVL CVL' : CVRecordList .
	vars AS AS' AS'' : AttributeSet .
	vars VC : Config .
	vars B : Bool .
	var X : Int .
	vars IL IL' IL1 IL1' : NatList .
	vars RO : Role .
	vars CRS : CRoleSet .
	var P : Float .

	op sampleInitCompromised : Nat Float NatList -> [NatList] .
	eq sampleInitCompromised(0, P, IL) = IL .
	rl sampleInitCompromised(s(N), P, IL) => 
		if sampleBerWithP(#ATTACK-PROB) then 
			sampleInitCompromised(N, P, N . IL) 
		else 
			sampleInitCompromised(N, P, IL) 
		fi . 

	---- makeVL(N): Generates a list of size N of (empty) general validator records 
	----
	---- e.g. makeVL(3) = < v(0),h(0),-32 > ; < v(1),h(0),-32 > ; < v(2),h(0),-32 >
	---- 
	op makeVL : Nat -> [VRecordList] .
	eq makeVL(0) = nilVHL .
	eq makeVL(s(N)) = makeVL(N) ; < v(N), sampleUniWithInt(#MAX-SEED-VALUE), h(0), sampleUniWithInt(#MAX-SEED-VALUE) , (- #DEPOSIT-SIZE) > .

	---- createInitDoReveals(IL, N): Generates a list of N scheduled elements containing 
	---- 'doReveal' messages targeted to validators whose indices are given in IL (we 
	---- assume N > length(IL)) 
	----
	---- e.g. createInitDoReveals(0 . 1 . 2, 3) =
	---- 		[0.01, v(0) <- doReveal(1), 0] ; 
	---- 		[1.01, v(1) <- doReveal(2), 0] ; 
	---- 		[2.01, v(2) <- doReveal(3), 0]
	---- 
	op createInitDoReveals : NatList Nat NatList -> [ScheduleList] .
	eq createInitDoReveals(nilIL, N, IL') 
		= nil .
	eq createInitDoReveals(IL . I, s(N), (IL1 . I . IL1')) 
		= createInitDoReveals(IL, N, (IL1 . I . IL1')) ; [0.01 + float(N), (v(I) <- doReveal(1, s(N))) , #MSG-DROP-PROB] .
	eq createInitDoReveals(IL . I, s(N), IL') 
		= createInitDoReveals(IL, N, IL') ; [0.01 + float(N), (v(I) <- doReveal(0, s(N))) , #MSG-DROP-PROB] [owise] .


	---- initBlockchain(N): Initialize the Blockchain object with N validator records
	op initBlockchain : Nat -> [Object] .
	eq initBlockchain(N) = 
		<name: bc |												---- The Blockchain Object
			seed:           sampleUniWithInt(#MAX-SEED-VALUE),  ---- seed of previous game round
			vpending:       nilVHL,             				---- list of pending validators 
			vpending-size:  0,                  				---- their count
			vapproved:          makeVL(N),     						---- list of approved validators (as general validator records) 
			vapproved-size:     N           						---- their count
		> .

	---- initAttacker(N): Initialize the Attacker object with N validator records
	op initAttacker : Nat -> [Object] .
	eq initAttacker(N) = 
		<name: a |								---- The Attacker Object
			vcomp:			nilCVL,       	---- Private validator records
			vcomp-ilist:	sampleInitCompromised(N, #ATTACK-PROB, nilIL),				---- list of compromised validator indices
			vcomp-size:		0,           		---- their count
			strategy:		0		---- the attacker's strategy 
		> .	

	---- initRandao(M, N, K): Initialize the RANDAO object with N validator records,
	---- M proposers and a deposit-per-validator given by K 
	op initRandao : Nat Nat Nat -> [Object] .
	eq initRandao(M, N, K) =
		<name: r |								---- The RANDAO Contract
			status:         ready,              ---- status can be 'ready' or 'processing'
			balance:        (N * K),       		---- current contract balance 
			success-rounds: 0,                  ---- number of successful rounds
			precords:      nilPL, 				---- proposers participating in the current game round
			prop-size:      M,                  ---- their count (in the steady state, this must be equal to #PROP-SIZE)
			prop-ilist: 	nilIL, 				---- their indices,       
			pnext:          1                   ---- next validator (time slot) to process
		> .

	---- initVGen(N, A): Initialize the validator generator object with N 
	---- as the next index, and A as the RANDAO object name 
	op initVGen : Nat ActorName -> [Object] .
	eq initVGen(N, RID) = 
		<name: g | 
			vcount: N, 
			contract: RID,
			next-seed: sampleUniWithInt(#MAX-SEED-VALUE),
			next-comp: sampleBerWithP(#ATTACK-PROB) > .

	---- initState: Generate the initial state of the protocol
	rl initState =>
		initSystem(
			initProposers(
				initBlockchain(#INIT-VLIST-SIZE)
				initAttacker(#INIT-VLIST-SIZE)
				initRandao(#CYCLE-LENGTH, #INIT-VLIST-SIZE, #DEPOSIT-SIZE)
				, #INIT-VLIST-SIZE, #CYCLE-LENGTH
		), #INIT-VLIST-SIZE
	) .

	---- initProposers(C, N, M): A helper function to initialize (in two steps)  
	---- the proposers list in the configuration C, given N as the total number  
	---- of validators in the system and M as the number of proposers

	---- The first step is to generate the list of proposer indices
	op initProposers : Config Nat Nat -> [Config] .
	eq initProposers(
		<name: bc | seed: S, AS >
		<name: r  |	prop-ilist: nilIL, AS' >        
		VC, N, M) 
		= initProposers(
			<name: bc | seed: S, AS >  
			<name: r  | prop-ilist: sampleIndexList(N, M, S), AS' >        
			VC, N, M) .

	---- The second step is form the list of proposer records 
	eq initProposers(
		<name: bc | vapproved: VHL, AS >  
		<name: r  |	prop-ilist: (I . IL), precords: nilPL, AS' >        
		<name: a  | vcomp: nilCVL, vcomp-ilist: IL', vcomp-size: 0, AS'' > 								
		VC, N, M) 
		= <name: bc | vapproved: VHL, AS >  
		  <name: r  | prop-ilist: (I . IL), precords: makePropRecords(I . IL), AS' >        
		  <name: a  | vcomp: setNewCVRoles(makeCVL((I . IL), IL'), (I . IL), VHL), vcomp-ilist: IL', vcomp-size: length(IL'), AS'' > 								
		  VC .

	---- initSystem(C, I): A helper function to initialize all validator records and the 
	---- configuration as a whole. The function walks through the set of validators, one-
	---- by-one updating their records. 

	---- If the validator is honest: Initialize its records 
	op initSystem : Config Nat -> [Config] .
	eq initSystem(
			<name: bc    | vapproved: (VHL ; < v(I), S, h(0), S', X >   ; VHL'), AS > 	
			VC, s(I))
		= initSystem(
				<name: bc    | vapproved: (VHL ; < v(I), S, h(S), S', X >   ; VHL'), AS > 	
				VC, I) .

	---- Once done with all validators, return the updated configuration agumented with
	---- the other configuration components (limit, round, validator generator, ... )
	eq initSystem(
			<name: r | prop-ilist: IL, prop-size: M, AS > 
			<name: a | vcomp-ilist: IL', AS' >  
			VC, 0) 
		= limit(false, 0.0)
		  round(1.0)
		  <name: r | prop-ilist: IL, prop-size: M, AS > 
		  <name: a | vcomp-ilist: IL', AS' >  
		  VC 
		  if #DYNAMIC-VLIST? then
			initVGen(#INIT-VLIST-SIZE, r)
			mytick(insertList({ 0.0 | createInitDoReveals(IL, M, IL') }, [1.0, r <- nextSlot(2), #MSG-DROP-PROB] ; [#VARRIVAL-DELAY, g <- spawn, 0] )) 		  	
		  else
			mytick(insert({ 0.0 | createInitDoReveals(IL, M, IL') }, [1.0, r <- nextSlot(2), #MSG-DROP-PROB])) 
		  fi .
endm


mod ANALYSIS-INTERFACE is
	protecting INIT-STATE .

    vars C : Config .
    vars B : Bool .
    vars D : Float .
    vars AID RID : ActorName .
    vars CVL : CVRecordList .
    vars AS AS' : AttributeSet .
	vars IL IL' IL1 IL1' : NatList .

    *******************************************************************
    ***** 0. matchScore: the number of compromised proposers in the 
    *****    proposers list
    *******************************************************************
    op matchScore : Config -> Float .
    eq matchScore(
		<name: AID | vcomp-ilist: IL, AS >  
		<name: RID | prop-ilist: IL', AS' >  
		C )
      = float(countCompromised(IL', IL)) .

    *******************************************************************
    ***** 1. lastWordScore: the length of the compromised tail (last 
    *****    revealers) of the proposers list
    *******************************************************************
	op lastWordScore : Config -> Float .
    eq lastWordScore(
		<name: AID | vcomp-ilist: IL, AS >  
		<name: RID | prop-ilist: IL', AS' >  
		C )
      = float(countCompromisedTail(IL', IL)) .


	***** to be used by PVeStA

	---- D is the game round number 
	---- B is a flag indicating whether the *macro tick* (or game round in this case) is ongoing
	---- tick is PVeStA's step 
    eq tick(limit(B, D) C) =  limit(true, D + 1.0) C .

    eq val(0, C) = matchScore(C) .
    eq val(1, C) = lastWordScore(C) .
endm










        
