
mod SAMPLER is
	protecting RANDOM .
	protecting COUNTER .
	protecting CONVERSION .

 	---- Basic random numbers 

	----  A float:  [0, 1]
	op rand : -> [Float] .
	rl [rnd] : rand => float(random(counter) / 4294967295) .

	----  A rational:  [0, 1]
	op rrand : -> [Rat] .
	rl [rrnd] : rrand => random(counter) / 4294967295 .
	
	----  A positive float:  (0, 1]
	op prand : -> [Float] .
	rl [prnd] : prand => float(s(random(counter)) / 4294967296) .

	----  A positive rational:  (0, 1]
	op prrand : -> [Rat] .
	rl [prrnd] : prrand => s(random(counter)) / 4294967296 .
	
	---- Sampling from probability distributions

	vars R Min Max : Float .
	vars N S : Nat .

	---- Bernoulli with bias R
	op sampleBerWithP : Float -> [Bool] .
	rl sampleBerWithP(R) => if rand < R then true else false fi . 

	---- Uniform from the list [0..(N-1)]  
	op sampleUniWithInt : Nat -> [Nat] .       
	rl sampleUniWithInt(N) => random(counter) rem N .

	---- Uniform over the range [Min,Max]
	op genRandom : Float Float -> [Float] .
	rl genRandom(Min, Max) => rand * (Max - Min) + Min .

	---- Exponential with mean R  	
	op sampleExpWithMean : Float -> [Float] .
  	rl sampleExpWithMean(R) => R * (- log(rand)) .

	---- Exponential with rate R
  	op sampleExpWithRate : Float -> [Float] .
   	rl sampleExpWithRate(R) => (- log(rand)) / R .
 	
endm

mod APMAUDE is
  pr FLOAT .
  pr NAT .

  sorts ActorName Attribute AttributeSet Content .
  sorts Actor Msg Object Config .
  subsort Attribute < AttributeSet .
  subsort Actor < Object .
  subsort Msg < Object .
  subsort Object < Config .
  ----subsort Float < Config .

  --- Messages
  op empty : -> Content .
  op _<-_ : ActorName Content -> Msg [prec 40 format (g o r o)] .

  --- Actors
  op <name:_|_> : ActorName AttributeSet -> Actor [format (nb! g b! nto b! o)] .
  op mt : -> AttributeSet .
  op null : -> Config .

  --- Configuration
  ----op flg : Bool Float -> Config . ---- a flag delimiting execution rounds

  op __ : Config Config -> Config [assoc comm id: null] .
  op _,_ : AttributeSet AttributeSet -> AttributeSet [assoc comm id: mt format (d d nt d) ] .

  sorts Scheduler ScheduleElem ScheduleList .
  subsort ScheduleElem < ScheduleList .
  subsort Scheduler < Config .

  op  nil : -> ScheduleList .
  op  _;_ : ScheduleList ScheduleList -> ScheduleList [assoc id: nil] .

  op [_,_,_] : Float Msg Nat -> ScheduleElem .  --- [t, m, p]: t -> time, m -> message, p -> drop?
  op {_|_} : Float ScheduleList -> Scheduler [format (nb! r b! o b! o)] .
  op insert : Scheduler ScheduleElem -> Scheduler .
  op insert : ScheduleList ScheduleElem -> ScheduleList .
  op insertList : Scheduler ScheduleList -> Scheduler .
  op insertList : ScheduleList ScheduleList -> ScheduleList .

  op tick : Config -> Config .
  op mytick : Scheduler -> Config .
  op global-time : Scheduler -> Float .
  op getTime : Config -> Float .
	
  var t1 t2 t gt : Float .
  var C : Config .
  var O O1 : Object .
  var p i : Nat .
  var SL SL' : ScheduleList .
  var e : ScheduleElem .
  var M1 M2 : Msg .

  eq global-time({ gt | SL }) = gt .
  eq getTime(C {gt | SL}) = gt .  

  eq insert({ gt | SL },e) = { gt | insert(SL,e) } .
  eq insert(SL , [ t2 , M2 , 1]) = SL .   
  eq insert([ t1 , M1 , p] ; SL , [ t2 , M2 , 0]) = 
       if t1 < t2 then [ t1 , M1 , p] ; insert(SL, [ t2 , M2 , 0]) 
                  else ([ t2 , M2 , 0] ; [ t1 , M1 , p] ; SL) fi .
  eq insert( nil , [ t2 , M2 , 0]) = [ t2 , M2 , 0] .

  eq insertList({ gt | SL }, SL') = { gt | insertList(SL, SL') } .
  eq insertList(SL , [t2 , M2, p] ; SL') = insertList( insert(SL, [t2, M2, p]), SL' ) .
  ---eq insertList( nil , SL') = SL' .
  eq insertList( SL , nil ) = SL .

  eq mytick({ gt | [ t1 , M1 , p] ; SL }) = M1 { t1 | SL } .
  
  op initState : -> Config .

  op sat : Nat Config -> Bool .
  op val : Nat Config -> Float .
endm	
	
