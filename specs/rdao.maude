***(
*** Part of rdao-smc: A probabilistic rewriting model of RANDAO schemes
*** 
*** Musab A. Alturki
*** Fall 2018
*** Runtime Verifcation Inc. 
)

---- An abstraction of hashing
mod HASH is
	protecting NAT .

	sort Seed Hash .
	subsort Nat < Seed .

	---- The hash operator
	op h : Seed -> Hash [ctor frozen] .

	vars S RS : Seed .

	---- Commit operation
	op commit : Seed -> Hash .
	eq commit(S) = h(S) .

	---- Reveal operation
	op reveal : Hash -> Nat .
	eq reveal(h(S)) = S .

	---- Combining (XOR'ing) seeds to get a new one 
	op newSeed : Seed Seed -> [Seed] .
	eq newSeed(RS, S) = (RS xor S) rem 4294967295 .
endm

---- Nat lists 
mod ILIST is
	extending HASH .
	protecting SAMPLER .

	sort IList .
	subsort Nat < IList .

	op nilIL : -> IList [ctor] .
	op _._ : IList IList -> IList [ctor assoc id: nilIL] .

	vars I M N K : Nat .
	vars S : Seed . 
	vars IL IL1 IL2 IL1' IL2' : IList .

	---- Compute a list of indices from the sequence of seeds S, S+1, ... , S+K
    op computeNewIList : Nat Nat Seed -> [IList] .
    eq computeNewIList(N, 0, S) = nilIL .
    eq computeNewIList(N, s(K), S) = random(S + K) rem N . computeNewIList(N, K, S) .

    ---- Compute the number of indices in the first list that appear in the second
	op matchScore : IList IList -> [Nat] .
	eq matchScore(IL1, IL2) = matchScore*(IL1, IL2, 0) .

	op matchScore* : IList IList Nat -> [Nat] .
	eq matchScore*((IL1 . I . IL1'), (IL2 . I . IL2'), N) = matchScore*((IL1 . IL1'), (IL2 . I . IL2'), s(N)) .
	eq matchScore*(IL1, IL2, N) = N [owise] .

    ---- Compute the size of the longest tail of indices in the first list that appear in the second
	op lastWordScore : IList IList -> [Nat] .
	eq lastWordScore(IL1, IL2) = lastWordScore*(IL1, IL2, 0) .

	op lastWordScore* : IList IList Nat -> [Nat] .
	eq lastWordScore*((IL1 . I), (IL2 . I . IL2'), N) = lastWordScore*(IL1, (IL2 . I . IL2'), s(N)) .
	eq lastWordScore*(IL1, IL2, N) = N [owise] .

endm

---- Nat sets
mod ISET is
	protecting NAT .

	sort ISet .
	subsort Nat < ISet .

	op mtIS : -> ISet [ctor] .
	op _,_ : ISet ISet -> ISet [ctor assoc comm id: mtIS] .

endm

---- Validator roles 
mod ROLES is 
	protecting ILIST .

	---- Compromized validator role positions
	sort CPosition .
	ops isolated ctailtail : -> CPosition [ctor] .
	op  ctailhead : IList -> CPosition [ctor] .

	---- Role types and constructors
	sort Role Honest CRoleSet CRole .
	subsort Honest CRoleSet < Role .
	subsort CRole < CRoleSet .

	op honest : -> Honest [ctor] .

	op [_:_] : Nat CPosition -> CRole [ctor].
	op mtCRS : -> CRoleSet [ctor] .
	op _,_ : CRoleSet CRoleSet -> CRoleSet [ctor comm assoc id: mtCRS] .
endm

---- Validator records
mod VRECORD is
	protecting APMAUDE .
	protecting ILIST .
	protecting ROLES .

	---- Public validator records
	sorts VRecord VRecordList .
	subsort VRecord < VRecordList .

	op <_,_,_> : ActorName Hash Int -> VRecord [ctor] .
	op nilVHL : -> VRecordList [ctor] .
	op _;_ : VRecordList VRecordList -> VRecordList [ctor assoc id: nilVHL] .

	---- Private compromized validator records
	sorts CVRecord CVRecordList .
	subsort CVRecord < CVRecordList .

	op <_,_,_> : ActorName Seed Role -> CVRecord [ctor] .
	op nilCVL : -> CVRecordList [ctor] .
	op _;_ : CVRecordList CVRecordList -> CVRecordList [ctor assoc id: nilCVL] .

	vars A : ActorName .
	vars S : Seed .
	vars H : Hash .
	vars VHL : VRecordList .
	vars I K : Nat .
	vars X : Int .
	vars R : Role .

	---- not used so far
	op getIDs : VRecordList -> ActorNameList .
	eq getIDs(nilVHL) = nilAN .
	eq getIDs(< A, H, X > ; VHL) = A ; getIDs(VHL) .

endm

---- Proposer records
mod PROPOSERS is
	protecting APMAUDE .

	sorts Proposer ProposerList .
	subsort Proposer < ProposerList .

	op [_,_] : ActorName Bool -> Proposer [ctor] .
	op nilPL : -> ProposerList [ctor] .
	op _;_ : ProposerList ProposerList -> ProposerList [ctor assoc id: nilPL] .

	vars A : ActorName .
	vars B : Bool .
	vars CL : ProposerList .

	---- not used so far
	op getIDs : ProposerList -> ActorNameList .
	eq getIDs(nilPL) = nilAN .
	eq getIDs([A, B] ; CL) = A ; getIDs(CL) .
endm

---- Attacker strategy
mod STRATEGY is
	protecting NAT .

	---- true means reveal, false means refrain 
	sort SkipList .
	subsort Bool < SkipList .

	op nilSKL : -> SkipList [ctor] .
	op _._ : SkipList SkipList -> SkipList [ctor assoc id: nilSKL] .

	sorts Strategy StrategyList .
	subsort Strategy < StrategyList .

	---- A strategy is a skiplist with a score 
	op [_:_] : Nat SkipList -> Strategy [ctor] .

	op nilSTL : -> StrategyList [ctor] .
	op __ : StrategyList StrategyList -> StrategyList [ctor assoc id: nilSTL] .


	vars N I : Nat . 
	vars SKL : SkipList .
	vars STL : StrategyList .

	---- Generate all possible strategies of a given length
	op enumStrategies : Nat -> [StrategyList] .
	eq enumStrategies(0) = [0 : nilSKL] .
	eq enumStrategies(s(N)) = augment(enumStrategies(N)) .
		
	op augment : StrategyList -> [StrategyList] .
	eq augment(nilSTL) = nilSTL .
	eq augment([I : SKL] STL) = [I : SKL . false] [I : SKL . true] augment(STL) .

endm

---- Actor attributes
mod ATTRIBUTES is
    protecting VRECORD .
    protecting PROPOSERS .
    protecting ILIST .
    protecting ISET .
    protecting STRATEGY .

    --- states of an actor
    sort Status .
    ops init processing waiting failed ready proposed refrained : -> Status . 

    --- Attributes
    op status:_         : Status		-> Attribute [format (m o d)] .  
    op balance:_        : Nat			-> Attribute [format (m o d)] .  
    op seed:_           : Seed			-> Attribute [format (m o d)] .
    op deposit:_        : Nat			-> Attribute [format (m o d)] .
    op vappr:_          : VRecordList 	-> Attribute [format (m o d)] .
    op vappr-size:_     : Nat			-> Attribute [format (m o d)] .
    op vpending:_       : VRecordList	-> Attribute [format (m o d)] .
    op vpending-size:_  : Nat			-> Attribute [format (m o d)] .
    op proposers:_      : ProposerList	-> Attribute [format (m o d)] .
    op prop-ilist:_     : IList			-> Attribute [format (m o d)] .
    op prop-size:_      : Nat			-> Attribute [format (m o d)] .
    op pnext:_          : Nat 			-> Attribute [format (m o d)] .
    op success-rounds:_ : Nat			-> Attribute [format (m o d)] .
    op contract:_       : ActorName 	-> Attribute [format (m o d)] .
    op slots:_   	    : ISet 			-> Attribute [format (m o d)] .
    op compromised:_    : Bool			-> Attribute [format (m o d)] .  
    op current-seed:_   : Nat			-> Attribute [format (m o d)] .
    op next-seed:_      : Seed 			-> Attribute [format (m o d)] .
    op vcomp:_ 			: CVRecordList	-> Attribute [format (m o d)] .
    op vcomp-size:_     : Nat			-> Attribute [format (m o d)] .
    op strategy:_ 		: Strategy 		-> Attribute [format (m o d)] .
endm

---- Actor names
mod OBJECTS is 
	extending APMAUDE .
    op v  : Nat -> ActorName .   --- Validators
    op bc :     -> ActorName .   --- Blockchain 
    op r  :     -> ActorName .   --- RANDAO Contract
    op a  :     -> ActorName .   --- Attacker
    op vg :     -> ActorName .   --- Validator Generator - not used for now (fixed validator set assumed)
    op o  :     -> ActorName .   --- Observer - not used so far           
endm

---- Message contents
mod MESSAGES is
    protecting VRECORD .
    protecting PROPOSERS .
   	extending APMAUDE .

	--- Message Contents
	op  reveal 		: ActorName Seed Hash 	-> Content . --- Revealing a seed and committing to the next one
	op  slot 		: ActorName Nat 		-> Content . --- Assigning a slot to a proposer
	op  nextSlot 	: Nat  					-> Content . --- A self message to schedule advancing the process to the next slot
	op  nextRound 	:   					-> Content . --- A self message to schedule advancing the process to the next round 
	op  doReveal	: Nat					-> Content . --- A self message to schedule a possible reveal action at the right slot 
	op  doReveal*	:				 		-> Content . --- A self message to schedule the second step of the reveal action 

	---- not used so far
	op  init		:				 		-> Content . --- initialize 
	op  spawn		:				-> Content . --- simulates client and validator arrivals
	op  join       : ActorName Nat -> Content . --- join the validator set
	op  leave      : ActorName Nat -> Content . --- leave the validator set	
	op  approved   : ActorName     -> Content . --- Approve a join request
	op  rejected   : ActorName     -> Content . --- Reject a join request
endm

---- Actor configuraiton
mod CONFIG is
	protecting ATTRIBUTES .
	protecting OBJECTS .
	protecting MESSAGES .
	protecting ILIST .

    --- Additional configuration fields
    op limit : Bool Float   -> Config [format (nb! o)] .
    op round : Float   -> Config [format (nb! o)] .
endm

---- RANDAO actions
mod RANDAO-BEHAVIOR is
	protecting CONFIG .
	protecting PARAMS .

	vars S S' RS : Seed .
	vars AS AS' AS'' : AttributeSet . 
	vars T TG TS TS' TR TR' D R F : Float .
	vars SL SL' : ScheduleList . 
	vars ST ST' : Strategy .
	vars SSTL STL STL' : StrategyList .
	vars CID VID RID OID AID BID : ActorName .
  	vars H H' : Hash .
	vars I J K L M N N' : Nat .
	vars AL : ActorNameList .
	vars VHL VHL' : VRecordList .
	vars CVL CVL' : CVRecordList .
	vars CL : ProposerList .
	vars C : Content .
	vars B B' T? : Bool .
	vars IL : IList .
	vars X : Int .
	vars RO : Role .
	vars SKL SKL' : SkipList .
	vars CRS : CRoleSet . 
	vars SDL : IList .
	vars IS : ISet .


	---- Advance the process to the next slot 
 rl [RAdvanceSlot] :
 	limit(true, D)
 	<name: BID |		
			seed:           S, 
			vappr-size:     N,
			AS >
 	<name: RID |		
			status:	ready, 
			proposers:	([ VID , B ] ; CL),
			prop-ilist: IL,       
			pnext:	K,
			AS' >
    { TG | SL }
    (RID <- nextSlot(L))
    => limit(TG <= #RLIMIT * D, D)
    	<name: BID |		
				seed:           S, 
				vappr-size:     N,
				AS >
    	if L > #VPINITSIZE then
    		---- End of game round: prepare to advance to the next round 
 			<name: RID |		
					status:	processing, 
					proposers:	([ VID , B ] ; CL),       
					prop-ilist: computeNewIList(N, #VPINITSIZE, S),       
					pnext:	1,
					AS' >
    		{ TG | SL }
    		(RID <- nextRound)
    	else 
    		if L == K then 
    			---- Slot was already advanced by a valid reveal -- so no changes 
 				<name: RID |		
						status:	ready, 
						proposers:	([ VID , B ] ; CL),       
						prop-ilist: IL,       
						pnext:	K,
						AS' >
			else
				---- Slot was not advanced -- advance it and record failure of a reveal
 				<name: RID |		
						status:	ready, 
						proposers:	(CL ; [ VID , false ]),       
						prop-ilist: IL,       
						pnext:	s(K),
						AS' >
			fi 
			mytick(insert({ TG | SL }, [floor(TG) + 1.0, (RID <- nextSlot(s(L))), 0])) 
		fi
    	[print TG ": RAdvanceSlot: from " K " to " L] .

    ---- Advance the process to the next round, update all records, form the new set of 
    ---- proposers and assign slots
  rl [RAdvanceRound] :
 	limit(true, D)
 	round(R)
 	<name: BID |		
			vappr:          VHL, 
			AS >
	<name: a   |
			vcomp: 			CVL,
			AS' >
 	<name: RID |		
			status:			processing, 
			balance: 		J,
			success-rounds: I, 
			proposers:      CL,
			prop-ilist:		IL, 
			prop-size:     	M,
			pnext:          K,
			AS'' >
    { TG | SL }
    (RID <- nextRound)
    =>  limit(TG <= #RLIMIT * D, D)
    	round(R + 1.0)
	 	<name: BID |		
				vappr:          updateRewards(VHL, CL), 
				AS >
		<name: a   |
				vcomp: 			setNewCVRoles(CVL, IL),
				AS' >
 		<name: RID |		
				status:			ready, 
				balance: 		J,
				success-rounds: s(I), 
				proposers:      formProposers(VHL, IL),
				prop-ilist:		IL, 
				prop-size:     	M,
				pnext:          1,
				AS'' >
		mytick(insertList(insert({ TG | SL }, [floor(TG) + 1.0, (RID <- nextSlot(2)), 0]), announceSlots(TG, RID, 0, IL))) 
    	[print TG ": RAdvanceRound with new committee " IL] .


    op updateRewards : VRecordList ProposerList -> [VRecordList] .
    eq updateRewards(VHL, nilPL) = VHL . 
    eq updateRewards((VHL ; < v(I) , H , X > ; VHL'), [ v(I) , B' ] ; CL) 
    	= updateRewards((VHL ; < v(I) , H , (if B' then X + 2 else X fi) > ; VHL'), CL) .


    op formProposers : VRecordList IList -> [ProposerList] .
    eq formProposers(VHL, nilIL) = nilPL . 
    eq formProposers((VHL ; < v(I) , H , X > ; VHL'), (I . IL)) = [ v(I) , false ] ; formProposers((VHL ; < v(I), H , X > ; VHL'), IL) .

    op setNewCVRoles : CVRecordList IList -> [CVRecordList] .
    eq setNewCVRoles(CVL, IL) = setNewCVRoles*(resetRoles(CVL), IL, #VPINITSIZE, true, nilIL) .

    op resetRoles : CVRecordList -> [CVRecordList] .
    eq resetRoles(nilCVL) =  nilCVL . 
    eq resetRoles(< v(I) , S, honest > ; CVL) = < v(I) , S, honest > ; resetRoles(CVL) .
    eq resetRoles(< v(I) , S, CRS > ; CVL)    = < v(I) , S, mtCRS > ; resetRoles(CVL) .

    op setNewCVRoles* : CVRecordList IList Nat Bool IList -> [CVRecordList] .
    eq setNewCVRoles*(CVL, nilIL, N, B, SDL) 
    	=  CVL . 
    eq setNewCVRoles*((CVL ; < v(I) , S, honest > ; CVL'), (IL . I), s(N), T?, SDL) 
    	= setNewCVRoles*((CVL ; < v(I) , S, honest > ; CVL'), IL, N, false, SDL) .
    eq setNewCVRoles*((CVL ; < v(I) , S, CRS > ; CVL'), (IL . I), s(N), false, SDL) 
    	= setNewCVRoles*((CVL ; < v(I) , S, (CRS , [s(N) : isolated]) > ; CVL'), IL, N, false, SDL) .
   ceq setNewCVRoles*((CVL ; < v(I) , S, CRS > ; CVL'), (IL . I), s(N), true, SDL) 
    	= if B then 
    		setNewCVRoles*((CVL ; < v(I) , S, (CRS , [s(N) : ctailtail]) > ; CVL'), IL, N, true, (S . SDL)) 
    	  else
    		setNewCVRoles*((CVL ; < v(I) , S, (CRS , [s(N) : ctailhead(S . SDL)]) > ; CVL'), IL, N, true, (S . SDL)) 
    	  fi
    	if B := isCEnd?((CVL ; < v(I) , S, CRS > ; CVL'), IL) .

    op isCEnd? : CVRecordList IList -> [Bool] .
    eq isCEnd?(CVL, nilIL) = false .
    eq isCEnd?((CVL ; < v(I) , S, honest > ; CVL'), (IL . I)) = false .
    eq isCEnd?((CVL ; < v(I) , S, CRS > ; CVL'), (IL . I)) = true .

    op announceSlots : Float ActorName Nat IList -> [ScheduleList] .
    eq announceSlots(TG, RID, N, nilIL) = nil .
    eq announceSlots(TG, RID, N, I . IL) = [TG + #NT-DELAY, (v(I) <- slot(RID, s(N))), #DROP?] ; announceSlots(TG, RID, s(N), IL) .


    ---- Process a reveal message 
 rl [RProcessReveal] :
 	limit(true, D)
 	<name: BID |		
			seed:	RS,  
			vappr:	(VHL ; < VID, H , X > ; VHL') ,   
			AS >
 	<name: RID |		
			status:	ready, 
			proposers:	([ VID , B ] ; CL),       
			pnext:	J,
			AS' >
    { TG | SL }
    (RID <- reveal(VID, S, H'))
    => limit(TG <= #RLIMIT * D, D)
    	if (H == h(S)) then 
    		---- The reveal is successful
		 	<name: BID |		
					seed:	newSeed(RS, S),  
					vappr:	(VHL ; < VID, H' , X > ; VHL') ,   
					AS >
 			<name: RID |		
					status:	ready, 
					proposers:	(CL ; [ VID , true ]),       
					pnext:	s(J),
					AS' >
		else
    		---- The reveal failed
		 	<name: BID |		
					seed:	RS,  
					vappr:	(VHL ; < VID, H , X > ; VHL') ,   
					AS >
 			<name: RID |		
					status:	ready, 
					proposers:	(CL ; [ VID , false ]),       
					pnext:	s(J),
					AS' >
		fi 
    	mytick({ TG | SL }) 
    	[print TG ": RProcessReveal received from " VID] .

---(
---- OLD
 crl [RAddV] : 
    limit(true, D)
	<name: RID  |
			vlist: PL,
			v-cnt: N,
			balance: M,
			AS > 
    { TG | SL }
    (RID <- join(VID, J))
    => limit(TG <= #RLIMIT * D, D)
		<name: RID  |
				vlist: (PL ; < VID, J >),
				v-cnt: s(N),
				balance: (M + J),
				AS > 
    	mytick(insert({ TG | SL }, [TG + #NT-DELAY, (VID <- approved(RID)), #DROP?]))
    if J >= #VDEPOSIT-MIN 
    [print TG ": RAddValidator: " RID " validator " VID " joined"] .

 crl [RRejV] : 
    limit(true, D)
	<name: RID  |
			vlist: PL,
			v-cnt: N,
			balance: M,
			AS > 
    { TG | SL }
    (RID <- join(VID, J))
    => limit(TG <= #RLIMIT * D, D)
		<name: RID  |
				vlist: PL,
				v-cnt: N,
				balance: M,
				AS > 
    	mytick(insert({ TG | SL }, [TG + #NT-DELAY, (VID <- rejected(RID)), #DROP?]))
    if J < #VDEPOSIT-MIN 
    [print TG ": RAddValidator: " RID " validator " VID " joined"] .

  rl [RInitRND] : 
    limit(true, D)
	<name: RID  |
			clist: CL,
			c-cnt: N,
			vlist: PL,
			v-cnt: N',
			balance: M,
			r-stime: TS,
			r-vl: PL',
			AS > 
    { TG | SL }
    (RID <- initRN)
    => limit(TG <= #RLIMIT * D, D)
		<name: RID  |
				clist: CL,
				c-cnt: N,
				vlist: PL,
				v-cnt: N',
				balance: M,
				r-stime: TG,
				r-vl: PL,
				AS > 
    	mytick(insertList({ TG | SL }, genSL(TG + #NT-DELAY, getIDs(PL), solicit(RID))))
    [print TG ": RInitRND: " RID " initiated RND process with " PL] .

	op genSL : Float ActorNameList Content -> ScheduleList .
	eq genSL(T, nilAN, C) = nil .
	eq genSL(T, A ; AL, C) = [T + genRandom(0.01,0.02), A <- C, #DROP?] .

)

endm
 
mod VALIDATOR-BEHAVIOR is
	protecting CONFIG .
	protecting PARAMS .

	vars S S' RS : Seed .
	vars AS AS' AS'' : AttributeSet . 
	vars T TG TS TS' TR TR' D R F : Float .
	vars SL SL' : ScheduleList . 
	vars CID VID RID OID AID BID : ActorName .
  	vars H : Hash .
	vars I J K L M N N' : Nat .
	vars AL : ActorNameList .
	vars VHL VHL' : VRecordList .
	vars CVL CVL' : CVRecordList .
	vars CL : ProposerList .
	vars C : Content .
	vars B : Bool .
	vars IL : IList .
	vars X : Int .
	vars RO : Role .
	vars CRS : CRoleSet . 
	vars ST ST' : Strategy .
	vars SSTL STL STL' : StrategyList .
	vars CP : CPosition .
	vars SKL SKL' : SkipList .
	vars SDL : IList .
	vars IS : ISet .


	---- A validator records an assigned slot and schedules a reveal message during that slot
  rl [VRecordSlot] : 
    limit(true, D)
    <name: VID |
			status: ready,	
	    	contract: RID,
			slots: IS, 
	    	AS >
    { TG | SL }
    (VID <- slot(RID, s(K)))
    => limit(TG <= #RLIMIT * D, D)
    	<name: VID |
				status: ready,	
	    		contract: RID,
				slots: (s(K), IS), 
	    		AS >
		mytick(insert( { TG | SL }, [ TG + float(K), (VID <- doReveal(s(K))) , #DROP?]))
	[print TG ": VRecordSlot: Slot s(" K ") assigned to " VID] .

	---- An honest validator revealing the seed along with a new commit 
  rl [VHonestReveal] : 
    limit(true, D)
    <name: VID |
			status: ready,	
	    	contract: RID,
			current-seed: S,  
			next-seed: S', 
			compromised: false,
			slots: (K, IS), 
	    	AS >
    { TG | SL }
    (VID <- doReveal(K))
    => limit(TG <= #RLIMIT * D, D)
    	<name: VID |
				status: ready,	
	    		contract: RID,
				current-seed: S',  
				next-seed: sampleUniWithInt(#MAXSEEDVALUE), 
				compromised: false,
				slots: IS, 
	    		AS >
		mytick(insert( { TG | SL }, [ TG + #NT-DELAY, (RID <- reveal(VID, S, h(S'))) , #DROP?] ))
	[print TG ": VReveal by " VID] .

	op getCompIList : CVRecordList -> [IList] .
	eq getCompIList(nilCVL) = nilIL .
	eq getCompIList(< v(I) , S, honest > ; CVL) = getCompIList(CVL) .
	eq getCompIList(< v(I) , S, CRS > ; CVL) = I . getCompIList(CVL) .

	---- A compromized validator with role "isolated" possibly revealing a seed
 crl [VCompReveal1] : 
    limit(true, D)
 	<name: BID |		
			seed:	RS,  
			AS >
	<name: AID |
			vcomp:	(CVL ; < VID , S, ([ K : isolated], CRS) > ; CVL'),  
			vcomp-size: N, 
			AS' >    
    <name: VID |
			status: ready,	
	    	contract: RID,
			current-seed: S,  
			next-seed: S', 
			compromised: true,
			slots: (K, IS), 
	    	AS'' >
	{ TG | SL }
    (VID <- doReveal(K))
    => limit(TG <= #RLIMIT * D, D)
	 	<name: BID |		
				seed:	RS,  
				AS >
		<name: AID |
				vcomp:	(CVL ; < VID , if B then S' else S fi , ([ K : isolated], CRS) > ; CVL'),   
				vcomp-size: N, 
				AS' >    
   	 	<name: VID |
				status: ready,	
	    		contract: RID,
	    		current-seed: if B then S' else S fi ,  
				next-seed: if B then sampleUniWithInt(#MAXSEEDVALUE) else S' fi, 
				compromised: true,
				slots: IS, 
	    		AS'' >
		if B then
			mytick(insert( { TG | SL }, [ TG + #NT-DELAY, (RID <- reveal(VID, S, h(S'))) , #DROP?] ))
		else
			mytick({ TG | SL })
		fi
		if B := 
			lastWordScore(
				computeNewIList(N, #VPINITSIZE, newSeed(RS, S)), 
				getCompIList(CVL ; < VID , S, ([ K : isolated], CRS) > ; CVL')
			) >= #ATTACKTHRESHOLD
		[print TG ": VCompReveal0 for slot " K " by " VID " => " B] .

	---- A compromized validator with role "ctailtail" possibly revealing a seed
 rl [VCompReveal2] : 
    limit(true, D)
 	<name: BID |		
			seed:	RS,  
			AS >    
	<name: AID |
			vcomp:	(CVL ; < VID , S, ([ K : ctailtail], CRS) > ; CVL'),   
			strategy: [J : B . SKL],
			AS' >    
    <name: VID |
			status: ready,	
	    	contract: RID,
			current-seed: S,  
			next-seed: S', 
			compromised: true,
			slots: (K, IS), 
	    	AS'' >
	{ TG | SL }
    (VID <- doReveal(K))
    => limit(TG <= #RLIMIT * D, D)
	 	<name: BID |		
				seed:	RS,  
				AS >    
		<name: AID |
				vcomp:	(CVL ; < VID , if B then S' else S fi, ([ K : ctailtail], CRS) > ; CVL'),   
				strategy: [J : SKL],
				AS' >    
   		<name: VID |
				status: ready,	
	    		contract: RID,
	    		current-seed: if B then S' else S fi ,  
				next-seed: if B then sampleUniWithInt(#MAXSEEDVALUE) else S' fi, 
				compromised: true,
				slots: IS, 
	    		AS'' >
	    if B then
			mytick(insert( { TG | SL }, [ TG + #NT-DELAY, (RID <- reveal(VID, S, h(S'))) , #DROP?] ))
		else
			mytick({ TG | SL })
		fi
		[print TG ": VCompReveal2 for slot " K " by " VID " => " B] .	    	

	---- A compromized validator with role "ctailhead" possibly revealing a seed
 crl [VCompReveal3] : 
    limit(true, D)
 	<name: BID |		
			seed:	RS,  
			AS >    
	<name: AID |
			vcomp:	(CVL ; < VID , S, ([ K : ctailhead(SDL)], CRS) > ; CVL'), 
			vcomp-size: N,  
			strategy: [J : SKL],
			AS' >  
    <name: VID |
			status: ready,	
	    	contract: RID,
			current-seed: S,  
			next-seed: S', 
			compromised: true,
			slots: (K, IS), 
	    	AS'' >
	{ TG | SL }
    (VID <- doReveal(K))
    => limit(TG <= #RLIMIT * D, D)
	 	<name: BID |		
				seed:	RS,  
				AS >    
		<name: AID |
				vcomp:	(CVL ; < VID , if B then S' else S fi, ([ K : ctailhead(SDL)], CRS) > ; CVL'),   
				vcomp-size: N,  
				strategy: [I : SKL'],
				AS' >  
   		<name: VID |
				status: ready,	
	    		contract: RID,
	    		current-seed: if B then S' else S fi ,  
				next-seed: if B then sampleUniWithInt(#MAXSEEDVALUE) else S' fi, 
				compromised: true,
				slots: IS, 
	    		AS'' >
	    if B then
			mytick(insert( { TG | SL }, [ TG + #NT-DELAY, (RID <- reveal(VID, S, h(S'))) , #DROP?] ))
		else
			mytick({ TG | SL })
		fi
	if STL        := enumStrategies(s(#VPINITSIZE - K))
	/\ SSTL       := computeAllScores((CVL ; < VID , S, ([ K : ctailhead(SDL)], CRS) > ; CVL'), STL, RS, SDL, N, #VPINITSIZE)
	/\ [I : B . SKL'] := findMaxScoreStrat(SSTL)
	[print TG ": VCompReveal3 for slot " K " by " VID " with strategy " B " . " SKL'] .	    	

	op computeAllScores : CVRecordList StrategyList Seed IList Nat Nat -> [StrategyList] .
	eq computeAllScores(CVL, nilSTL, RS, SDL, N, M) = nilSTL .
	eq computeAllScores(CVL, (ST STL), RS, SDL, N, M) 
		= computeScore(CVL, ST, RS, SDL, N, M) computeAllScores(CVL, STL, RS, SDL, N, M) .

	op computeScore : CVRecordList Strategy Seed IList Nat Nat -> [Strategy] .
	--- eq computeScore([I : nilSKL], RS, (S . SDL), N, M) = [I : nilSKL] . 
	ceq computeScore(CVL, [I : B . SKL], RS, (S . SDL), N, M) 
		= [K : B . SKL]
		if K := lastWordScore(computeNewIList(N, M, if B then newSeed(RS, S) else RS fi), getCompIList(CVL)) . 
	
	op findMaxScoreStrat : StrategyList -> [Strategy] .
	eq findMaxScoreStrat(ST STL) = findMaxScoreStrat*(STL, ST) .

	op findMaxScoreStrat* : StrategyList Strategy -> [Strategy] .
	eq findMaxScoreStrat*(nilSTL, ST) = ST .
	eq findMaxScoreStrat*([I : SKL] STL, [K : SKL']) 
		= if I > K then 
			findMaxScoreStrat*(STL, [I : SKL])
		  else 
			findMaxScoreStrat*(STL, [K : SKL'])
		  fi .







---(
---- OLD
	---- a new validator arrives and requests to join
  rl [VArrive] : 
    limit(true, D)
    <name: vg |
	    	cnt: K, 
	    	contract: RID,
	    	AS >
    { TG | SL }
    (vg <- spawn)
    => limit(TG <= #RLIMIT * D, D)
    	<name: vg |
	    		cnt: s(K), 
		    	contract: RID,
	    		AS >
		<name: v(K)  |
				status: waiting,
				balance: (#INIT-VBALANCE - #VDEPOSIT),
		    	contract: RID,
		    	seed: random(counter),
				rnd: 0,
				AS >   
		insert( { TG | SL }, [ TG + #VARRIVE-DELAY, (vg <- spawn) , #DROP?] )
	    (r <- join(v(K), #VDEPOSIT, ))       
	[print TG ": VArrive: " K] .

	---- a validator is approved to the validator set 
 rl [VApproved] : 
    limit(true, D)
	<name: VID  |
			status: waiting,
			contract: RID,
			rnd: 0,
			AS > 
----	<name: OID  |
----			success-cnt: I,
----			retries-avg: R,
----			stime-round: TR,
----			stime-total: TR',
----			AS' > 
    { TG | SL }
    (VID <- approved(RID))
    => limit(TG <= #RLIMIT * D, D)
		<name: VID  |
				status: ready,
				contract: RID,
				rnd: 0,
				AS > 		
----	<name: OID  |
----			success-cnt: I,
----			retries-avg: R,
----			stime-round: TR,
----			stime-total: TR',
----			AS' > 
    	mytick({ TG | SL }) 
    [print "VApproved: " VID] .

	---- a validator is solicited to provide a seed and immediately proposes one
 rl [VPropose] : 
    limit(true, D)
	<name: VID  |
			status: ready,
			contract: RID,
		    seed: S,
			rnd: 0,
			AS > 
----	<name: OID  |
----			success-cnt: I,
----			retries-avg: R,
----			stime-round: TR,
----			stime-total: TR',
----			AS' > 
    { TG | SL }
    (VID <- solicit(RID))
    => limit(TG <= #RLIMIT * D, D)
		<name: VID  |
				status: proposed,
				contract: RID,
		    	seed: S,
				rnd: 0,
				AS > 		
----	<name: OID  |
----			success-cnt: I,
----			retries-avg: R,
----			stime-round: TR,
----			stime-total: TR',
----			AS' > 
		mytick(insert( { TG | SL }, [ TG + #NT-DELAY, (RID <- propose(VID, S)) , #DROP?] ))
    [print "VPropose: " VID] .

	---- a validator receives notification of rnd generation success
 rl [VSuccess] : 
    limit(true, D)
		<name: VID  |
				status: proposed,
				contract: RID,
				balance: K,
		    	seed: S,
				AS > 	
    { TG | SL }
    (VID <- succeeded(RID, J))
    => limit(TG <= #RLIMIT * D, D)
		<name: VID  |
				status: ready,
				contract: RID,
				balance: (K + J),
		    	seed: random(counter),
				AS > 	
    	mytick({ TG | SL }) 
    [print "VSuccess: " VID " with profit " J] .

	---- a validator receives notification of rnd generation failure
 rl [VFail] : 
    limit(true, D)
		<name: VID  |
				status: proposed,
				contract: RID,
				balance: K,
		    	seed: S,
				AS > 	
    { TG | SL }
    (VID <- failed(RID))
    => limit(TG <= #RLIMIT * D, D)
		<name: VID  |
				status: ready,
				contract: RID,
				balance: K,
		    	seed: random(counter),
				AS > 	
    	mytick({ TG | SL }) 
    [print "VFail: " VID] .


)
endm

mod INIT-STATE is
	protecting VALIDATOR-BEHAVIOR .
	protecting RANDAO-BEHAVIOR .

	vars I J M N K : Nat .
	vars S : Seed .
	vars RID VID AID : ActorName .
	vars AL : ActorNameList .
	vars VHL VHL' : VRecordList .
	vars CVL CVL' : CVRecordList .
	vars AS AS' AS'' : AttributeSet .
	vars VC : Config .
	vars B : Bool .
	var X : Int .
	vars IL : IList .

	---- Generate an initial list of validator objects
	op spawnValidatorSet : Nat ActorName Nat -> [Config] .
	eq spawnValidatorSet(0, RID, K) 
		= null .
	eq spawnValidatorSet(s(N), RID, K) 
		= spawnValidator(N, RID, K) spawnValidatorSet(N, RID, K) .

	op spawnValidator : Nat ActorName Nat -> [Object] .
	eq spawnValidator(N, RID, K) 
		= <name: v(N)  |										---- A validator with unique id v(N)
				status: ready,									---- status of a validator
				contract: RID,									---- the RANDAO contract with which the validator interacts 
				balance: K,										---- current validator balance
				slots: mtIS,					 				---- the time slot assigned (mtIS means not a committee member)
				compromised: sampleBerWithP(#VCOMPROMIZED),  	---- true iff controled by the attacker
				current-seed: sampleUniWithInt(#MAXSEEDVALUE),	---- random seed for current round 
				next-seed: sampleUniWithInt(#MAXSEEDVALUE)    	---- random seed for next round 
			> .	

	---- Generate a list of (empty) public validator records
	op makeVL : Nat -> [VRecordList] .
	eq makeVL(0) = nilVHL .
	eq makeVL(s(N)) = makeVL(N) ; < v(N), h(0) , (- #VDEPOSIT) > .

	---- Generate a list of (empty) private validator records (to be used by the attacker)
	op makeCVL : Nat -> [CVRecordList] .
	eq makeCVL(0) = nilCVL .
	eq makeCVL(s(N)) =  makeCVL(N) ; < v(N), 0, honest > .

	---- Generate a list of scheduled messages assigning initial slots to proposers
	op createInitSL : IList Nat -> [ScheduleList] .
	eq createInitSL(nilIL, N) = nil .
	eq createInitSL(IL . I, s(N)) = createInitSL(IL, N) ; [0.1, (v(I) <- slot(r, s(N))) , #DROP?] .


	---- Initialize the Blockchain object 
	op initBlockchain : Nat -> [Object] .
	eq initBlockchain(N) = 
		<name: bc |												---- The Blockchain Object
			status:         ready,              				---- status can be 'ready', 'processing' or 'done'
			seed:           sampleUniWithInt(#MAXSEEDVALUE),    ---- seed of previous game round
			vpending:       nilVHL,             				---- list of pending validators 
			vpending-size:  0,                  				---- their count
			vappr:          makeVL(N),     						---- list of approved validators (as public validator records) 
			vappr-size:     N           						---- their count
		> .

	op initAttacker : Nat -> [Object] .
	eq initAttacker(N) = 
		<name: a |								---- The Attacker Object
			status:			ready,              ---- status can be 'ready', 'processing' or 'done'
			vcomp:			makeCVL(N),       	---- Private validator records
			vcomp-size:		N,           		---- their count
			strategy:		[0 : nilSKL]		---- the attacker's strategy (for tails controlled by the attacker)
		> .	

	op initRandao : Nat Nat Nat -> [Object] .
	eq initRandao(M, N, K) =
		<name: r |								---- The RANDAO Contract
			status:         ready,              ---- status can be 'ready', 'processing' or 'done'
			balance:        (N * K),       		---- current contract balance 
			success-rounds: 0,                  ---- number of successful rounds
			proposers:      nilPL, 				---- proposers participating in the current game round
			prop-size:      M,                  ---- their count (in the steady state, this must be equal to #PROP-SIZE)
			prop-ilist: 	nilIL, 				---- their indices,       
			pnext:          1                   ---- next validator (time slot) to process
		> .


 	--- Initial State  
	rl initState =>
		initSystem(
			initProposers(
				initBlockchain(#VINITSIZE)
				initAttacker(#VINITSIZE)
				initRandao(#VPINITSIZE, #VINITSIZE, #VDEPOSIT)
				spawnValidatorSet(#VINITSIZE, r, #INIT-VBALANCE - #VDEPOSIT), #VINITSIZE, #VPINITSIZE
		), #VINITSIZE
	) .

	---- A helper function to initialize the proposers list 
	op initProposers : Config Nat Nat -> [Config] .
	eq initProposers(
		<name: bc | seed: S, AS >
		<name: r  |	prop-ilist: nilIL, AS' >        
		VC, N, M) 
		= initProposers(
			<name: bc | seed: S, AS >  
			<name: r  | prop-ilist: computeNewIList(N, M, S), AS' >        
			VC, N, M) .

	eq initProposers(
		<name: bc | vappr: VHL, AS >  
		<name: r  |	prop-ilist: (I . IL), proposers: nilPL, AS' >        
		VC, N, M) 
		= <name: bc | vappr: VHL, AS >  
		  <name: r  | prop-ilist: (I . IL), proposers: formProposers(VHL, (I . IL)), AS' >        
		  VC .

	---- A helper function to initialize all validator records and the configuration as a whole 
	op initSystem : Config Nat -> [Config] .
	eq initSystem(
			<name: bc    | vappr: (VHL ; < v(I), h(0), X >   ; VHL'), AS > 	
			<name: a     | vcomp: (CVL ; < v(I), 0, honest > ; CVL'), AS' > 								
			<name: v(I)  | current-seed: S, compromised: B, AS'' >
			VC, s(I))
		= initSystem(
				<name: bc    | vappr: (VHL ; < v(I), h(S), X > ; VHL'), AS > 	
				<name: a     | vcomp: (CVL ; < v(I), if B then S else 0 fi, if B then mtCRS else honest fi > ; CVL'), AS' > 								
				<name: v(I)  | current-seed: S, compromised: B, AS'' >
				VC, I) .
	eq initSystem(
			<name: r | prop-ilist: IL, prop-size: M, AS > 
			<name: a | vcomp: CVL, AS' > 
			VC, 0) 
		= limit(false, 0.0)
		  round(1.0)
		  <name: r | prop-ilist: IL, prop-size: M, AS > 
		  <name: a | vcomp: setNewCVRoles(CVL, IL), AS' > 
		  VC 
		  mytick(insert({ 0.0 | createInitSL(IL, M) }, [1.0, r <- nextSlot(2), #DROP?])) .

endm


mod ANALYSIS-INTERFACE is
	protecting INIT-STATE .

    var  C : Config .
    var  B : Bool .
    var  D : Float .

	***** to be used by PVeStA

	---- D is the game round number 
	---- B is a flag indicating whether the *macro tick* (or game round in this case) is ongoing
	---- tick is PVeStA's step 
    eq tick(limit(B, D) C) =  limit(true, D + 1.0) C .

endm










        
